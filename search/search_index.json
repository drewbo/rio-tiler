{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rio-tiler \u00b6 Rasterio plugin to read mercator tiles from Cloud Optimized GeoTIFF. Install \u00b6 You can install rio-tiler using pip $ pip install -U pip $ pip install rio-tiler --pre # version 2.0 is in development or install from source: $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -U pip $ pip install -e . Usage \u00b6 The rio_tiler module can create mercator tiles from any raster source supported by Rasterio/GDAL (i.e. local files, http, s3, gcs etc.). Additional method are availables (see COGReader ) Read a tile from a file \u00b6 from rio_tiler.io import COGReader with COGReader ( \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) print ( mask . shape ) > ( 256 , 256 ) Render the array as an image (PNG/JPEG) \u00b6 from rio_tiler.utils import render buffer = render ( tile , mask = mask ) # this returns a buffer (PNG by default) Rescale non-byte data and/or apply colormap from rio_tiler.colormap import cmap from rio_tiler.utils import linear_rescale # Rescale the tile array only where mask is valid and cast it to byte tile = numpy . where ( mask , linear_rescale ( tile , in_range = ( 0 , 1000 ), out_range = [ 0 , 255 ]), 0 ) . astype ( numpy . uint8 ) cm = cmap . get ( \"viridis\" ) buffer = render ( tile , mask = mask , colormap = cm ) Use creation options to match mapnik defaults. from rio_tiler.utils import render from rio_tiler.profiles import img_profiles options = img_profiles . get ( \"webp\" ) buffer = render ( tile , mask = mask , img_format = \"webp\" , ** options ) Write image to file with open ( \"my.png\" , \"wb\" ) as f : f . write ( buffer ) COGReader \u00b6 class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. info: dict General information about the COG (datatype, indexes, ...) stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\" Properties \u00b6 dataset : Return the rasterio dataset colormap : Return the dataset's internal colormap minzoom : Return minimum Mercator Zoom maxzoom : Return maximum Mercator Zoom bounds : Return the dataset bounds in WGS84 center : Return the center of the dataset + minzoom spatial_info : Return the bounds, center and zoom infos Methods \u00b6 tile() : Read map tile from a raster with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" s ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , expression = \"B1/B2\" ) part() : Read part of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 )) # Limit output size (default is set to 1024) with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = 2000 ) # Read high resolution with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = None ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), expression = \"B1/B2\" ) preview() : Read a preview of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview () # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( expression = \"B1+2,B1*4\" ) point() : Read point value of a raster with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 )) # With indexes with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , indexes = 1 )) [ 1 ] # With expression with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , expression = \"B1+2,B1*4\" )) [ 3 , 4 ] info() : Return simple metadata about the dataset with COGReader ( \"myfile.tif\" ) as cog : print ( cog . info ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } } stats() : Return image statistics (Min/Max/Stdev) with COGReader ( \"myfile.tif\" ) as cog : print ( cog . stats ()) { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } metadata() : Return COG info + statistics with COGReader ( \"myfile.tif\" ) as cog : print ( cog . metadata ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } \"statistics\" : { 1 : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } } Global Options \u00b6 COGReader accept several options which will be forwarded to the rio_tiler.reader._read function (low level function accessing the data): - nodata : Overwrite the nodata value (or set if not present) - unscale : Apply internal rescaling factors - vrt_options : Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions ) Note: Those options could already be passed on each method call. with COGReader ( \"my_cog.tif\" , nodata = 0 ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 ) # is equivalent to with COGReader ( \"my_cog.tif\" ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 , nodata = 0 ) STACReader \u00b6 In rio-tiler v2, we added a rio_tiler.io.STACReader to allow tile/metadata fetching of assets withing a STAC item. The STACReader objects has the same properties/methods as the COGReader. from typing import Dict from rio_tiler.io import STACReader with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : print ( stac . bounds ) print ( stac . assets ) > [ 23.293255090449595 , 31.505183020453355 , 24.296453548295318 , 32.51147809805106 ] > [ 'overview' , 'visual' , 'B01' , 'B02' , 'B03' , 'B04' , 'B05' , 'B06' , 'B07' , 'B08' , 'B8A' , 'B09' , 'B11' , 'B12' , 'AOT' , 'WVP' , 'SCL' ] # Name of assets to read assets = [ \"B01\" , \"B02\" ] with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , assets = assets ) print ( tile . shape ) > ( 2 , 256 , 256 ) # With expression with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , expression = \"B01/B02\" ) print ( tile . shape ) > ( 1 , 256 , 256 ) Note: STACReader is based on rio_tiler.io.base.MultiBaseReader class. Working with multiple assets \u00b6 Mosaic \u00b6 Starting in rio-tiler 2.0, we've transfered the rio-tiler-mosaic plugin to be a rio-tiler submodule. from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , 1 , 1 , 1 ) Learn more about rio_tiler.mosaic in doc/mosaic.md . Notebook: WorkingWithMosaic Merge assets \u00b6 rio_tiler.io.cogeo submodule has multi_* functions (tile, part, preview, point, metadata, info, stats) allowing to fetch and merge info/data from multiple dataset (think about multiple bands stored in separated files). from typing import Dict from rio_tiler.io.cogeo import multi_tile assets = [ \"b1.tif\" , \"b2.tif\" , \"b3.tif\" ] tile , mask = multi_tile ( assets , x , y , z , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) # Others metadata = multi_info ( assets ) stats = multi_stats ( assets , pmin = 2 , pmax = 98 , ... ) metadata = multi_metadata ( assets , pmin = 2 , pmax = 98 , ... ) values = multi_points ( assets , lon , lat , ... ) data , mask = multi_part ( assets , bbox , ... ) data , mask = multi_preview ( assets , ... ) You can also use rio_tiler.io.base.MultiBaseReader to build a custom asset reader: import attr from rio_tiler.io.base import MultiBaseReader from rio_tiler.io import COGReader , BaseReader # CustomReader is a subclass of MultiBaseReader. # To ease the creation of the class and because MultiBaseReader is built with `attr` # we also need to add the `@attr.s` wrapper on top of our custom class. @attr . s class CustomReader ( MultiBaseReader ): directory : str = attr . ib () # required arg reader : Type [ BaseReader ] = attr . ib ( default = COGReader ) # the default reader is COGReader def __enter__ ( self ): # List files in directory dirs = os . listdir ( self . directory ) # get list of tifs tiff = [ f for f in dirs if f . endswith ( \".tif\" )] # create list of assets names - REQUIRED self . assets = [ os . path . basename ( f ) . split ( \".\" )[ 0 ] for f in tiff ] # `self.bounds` needs to be set! - REQUIRED with self . reader ( tiff [ 0 ]) as cog : self . bounds = cog . bounds return self def _get_asset_url ( self , asset : str ) -> str : \"\"\"Validate asset names and return asset's url.\"\"\" if asset not in self . assets : raise InvalidAssetName ( f \" { asset } is not valid\" ) return os . path . join ( self . directory , f \" { asset } .tif\" ) # we have a directoty with \"b1.tif\", \"b2.tif\", \"b3.tif\" with CustomReader ( \"my_dir/\" ) as cr : print ( cr . assets ) tile , mask = cr . tile ( x , y , z , assets = \"b1\" ) > [ \"b1\" , \"b2\" , \"b3\" ] print ( tile . shape ) > ( 3 , 256 , 256 ) Reading asset with a GeoJSON Polygon \u00b6 Natively rio-tiler support mostly bbox reading. Using GDALWarpVRT Cutline option, it's possible to read a dataset for a given polygon. from rio_tiler.io import COGReader from rio_tiler.utils import create_cutline from rasterio.features import bounds as featureBounds feat = { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ - 52.6025390625 , 73.86761239709705 ], [ - 52.6025390625 , 73.59679245247814 ], [ - 51.591796875 , 73.60299628304274 ], [ - 51.591796875 , 73.90420357134279 ], [ - 52.4267578125 , 74.0437225981325 ], [ - 52.6025390625 , 73.86761239709705 ] ] ] } } # Get BBOX of the polygon bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Read part of the data (bbox) and use the cutline to mask the data data , mask = cog . part ( bbox , vrt_options = { 'cutline' : cutline }) The previous example uses the .part method but any method that uses the rio_tiler.reader._read function will accept the cutline options. bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Get a preview of the whole geotiff but use the cutline to mask the data data , mask = cog . preview ( vrt_options = { 'cutline' : cutline }) # Read a mercator tile and use the cutline to mask the data data , mask = cog . tile ( 1 , 1 , 1 , vrt_options = { 'cutline' : cutline }) # Get image statistics over a bbox and use the cutline as mask stats = cog . stats ( bounds = bbox , vrt_options = { 'cutline' : cutline }) Partial reading on Cloud hosted dataset \u00b6 Rio-tiler perform partial reading on local or distant dataset, which is why it will perform best on Cloud Optimized GeoTIFF (COG). It's important to note that Sentinel-2 scenes hosted on AWS are not in Cloud Optimized format but in JPEG2000 . When performing partial reading of JPEG2000 dataset GDAL (rasterio backend library) will need to make a lot of GET requests and transfer a lot of data. Ref: Do you really want people using your data blog post. Create an AWS Lambda package \u00b6 The easiest way to make sure the package will work on AWS is to use docker FROM lambci/lambda:build-python3.7 ENV LANG = en_US.UTF-8 LC_ALL = en_US.UTF-8 CFLAGS = \"--std=c99\" RUN pip3 install rio-tiler --no-binary numpy -t /tmp/python -U RUN cd /tmp/python && zip -r9q /tmp/package.zip * Ref: vincentsarago/simple-rio-lambda Mission Specific tiler \u00b6 In rio-tiler v2 we choosed to remove the mission specific tilers (Sentinel2, Sentinel1, Landsat8 and CBERS). Those are now in a specific plugin: rio-tiler-pds . Plugins \u00b6 rio-tiler-mvt : Create Mapbox Vector Tile from numpy array (tile/mask) rio-tiler-crs : Create Map Tiles using other TileMatrixSets rio-viz : Visualize Cloud Optimized GeoTIFF in browser locally Implementations \u00b6 CosmiQ/solaris cogeo-tiler titiler Contribution & Development \u00b6 Issues and pull requests are more than welcome. dev install $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -e . [ dev ] Python3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install License \u00b6 See LICENSE.txt Authors \u00b6 The rio-tiler project was begun at Mapbox and has been transferred in January 2019. See AUTHORS.txt for a listing of individual contributors. Changes \u00b6 See CHANGES.txt .","title":"Home"},{"location":"#rio-tiler","text":"Rasterio plugin to read mercator tiles from Cloud Optimized GeoTIFF.","title":"Rio-tiler"},{"location":"#install","text":"You can install rio-tiler using pip $ pip install -U pip $ pip install rio-tiler --pre # version 2.0 is in development or install from source: $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -U pip $ pip install -e .","title":"Install"},{"location":"#usage","text":"The rio_tiler module can create mercator tiles from any raster source supported by Rasterio/GDAL (i.e. local files, http, s3, gcs etc.). Additional method are availables (see COGReader )","title":"Usage"},{"location":"#read-a-tile-from-a-file","text":"from rio_tiler.io import COGReader with COGReader ( \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) print ( mask . shape ) > ( 256 , 256 )","title":"Read a tile from a file"},{"location":"#render-the-array-as-an-image-pngjpeg","text":"from rio_tiler.utils import render buffer = render ( tile , mask = mask ) # this returns a buffer (PNG by default) Rescale non-byte data and/or apply colormap from rio_tiler.colormap import cmap from rio_tiler.utils import linear_rescale # Rescale the tile array only where mask is valid and cast it to byte tile = numpy . where ( mask , linear_rescale ( tile , in_range = ( 0 , 1000 ), out_range = [ 0 , 255 ]), 0 ) . astype ( numpy . uint8 ) cm = cmap . get ( \"viridis\" ) buffer = render ( tile , mask = mask , colormap = cm ) Use creation options to match mapnik defaults. from rio_tiler.utils import render from rio_tiler.profiles import img_profiles options = img_profiles . get ( \"webp\" ) buffer = render ( tile , mask = mask , img_format = \"webp\" , ** options ) Write image to file with open ( \"my.png\" , \"wb\" ) as f : f . write ( buffer )","title":"Render the array as an image (PNG/JPEG)"},{"location":"#cogreader","text":"class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. info: dict General information about the COG (datatype, indexes, ...) stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\"","title":"COGReader"},{"location":"#properties","text":"dataset : Return the rasterio dataset colormap : Return the dataset's internal colormap minzoom : Return minimum Mercator Zoom maxzoom : Return maximum Mercator Zoom bounds : Return the dataset bounds in WGS84 center : Return the center of the dataset + minzoom spatial_info : Return the bounds, center and zoom infos","title":"Properties"},{"location":"#methods","text":"tile() : Read map tile from a raster with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" s ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , expression = \"B1/B2\" ) part() : Read part of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 )) # Limit output size (default is set to 1024) with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = 2000 ) # Read high resolution with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = None ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), expression = \"B1/B2\" ) preview() : Read a preview of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview () # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( expression = \"B1+2,B1*4\" ) point() : Read point value of a raster with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 )) # With indexes with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , indexes = 1 )) [ 1 ] # With expression with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , expression = \"B1+2,B1*4\" )) [ 3 , 4 ] info() : Return simple metadata about the dataset with COGReader ( \"myfile.tif\" ) as cog : print ( cog . info ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } } stats() : Return image statistics (Min/Max/Stdev) with COGReader ( \"myfile.tif\" ) as cog : print ( cog . stats ()) { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } metadata() : Return COG info + statistics with COGReader ( \"myfile.tif\" ) as cog : print ( cog . metadata ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } \"statistics\" : { 1 : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } }","title":"Methods"},{"location":"#global-options","text":"COGReader accept several options which will be forwarded to the rio_tiler.reader._read function (low level function accessing the data): - nodata : Overwrite the nodata value (or set if not present) - unscale : Apply internal rescaling factors - vrt_options : Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions ) Note: Those options could already be passed on each method call. with COGReader ( \"my_cog.tif\" , nodata = 0 ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 ) # is equivalent to with COGReader ( \"my_cog.tif\" ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 , nodata = 0 )","title":"Global Options"},{"location":"#stacreader","text":"In rio-tiler v2, we added a rio_tiler.io.STACReader to allow tile/metadata fetching of assets withing a STAC item. The STACReader objects has the same properties/methods as the COGReader. from typing import Dict from rio_tiler.io import STACReader with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : print ( stac . bounds ) print ( stac . assets ) > [ 23.293255090449595 , 31.505183020453355 , 24.296453548295318 , 32.51147809805106 ] > [ 'overview' , 'visual' , 'B01' , 'B02' , 'B03' , 'B04' , 'B05' , 'B06' , 'B07' , 'B08' , 'B8A' , 'B09' , 'B11' , 'B12' , 'AOT' , 'WVP' , 'SCL' ] # Name of assets to read assets = [ \"B01\" , \"B02\" ] with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , assets = assets ) print ( tile . shape ) > ( 2 , 256 , 256 ) # With expression with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , expression = \"B01/B02\" ) print ( tile . shape ) > ( 1 , 256 , 256 ) Note: STACReader is based on rio_tiler.io.base.MultiBaseReader class.","title":"STACReader"},{"location":"#working-with-multiple-assets","text":"","title":"Working with multiple assets"},{"location":"#mosaic","text":"Starting in rio-tiler 2.0, we've transfered the rio-tiler-mosaic plugin to be a rio-tiler submodule. from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , 1 , 1 , 1 ) Learn more about rio_tiler.mosaic in doc/mosaic.md . Notebook: WorkingWithMosaic","title":"Mosaic"},{"location":"#merge-assets","text":"rio_tiler.io.cogeo submodule has multi_* functions (tile, part, preview, point, metadata, info, stats) allowing to fetch and merge info/data from multiple dataset (think about multiple bands stored in separated files). from typing import Dict from rio_tiler.io.cogeo import multi_tile assets = [ \"b1.tif\" , \"b2.tif\" , \"b3.tif\" ] tile , mask = multi_tile ( assets , x , y , z , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) # Others metadata = multi_info ( assets ) stats = multi_stats ( assets , pmin = 2 , pmax = 98 , ... ) metadata = multi_metadata ( assets , pmin = 2 , pmax = 98 , ... ) values = multi_points ( assets , lon , lat , ... ) data , mask = multi_part ( assets , bbox , ... ) data , mask = multi_preview ( assets , ... ) You can also use rio_tiler.io.base.MultiBaseReader to build a custom asset reader: import attr from rio_tiler.io.base import MultiBaseReader from rio_tiler.io import COGReader , BaseReader # CustomReader is a subclass of MultiBaseReader. # To ease the creation of the class and because MultiBaseReader is built with `attr` # we also need to add the `@attr.s` wrapper on top of our custom class. @attr . s class CustomReader ( MultiBaseReader ): directory : str = attr . ib () # required arg reader : Type [ BaseReader ] = attr . ib ( default = COGReader ) # the default reader is COGReader def __enter__ ( self ): # List files in directory dirs = os . listdir ( self . directory ) # get list of tifs tiff = [ f for f in dirs if f . endswith ( \".tif\" )] # create list of assets names - REQUIRED self . assets = [ os . path . basename ( f ) . split ( \".\" )[ 0 ] for f in tiff ] # `self.bounds` needs to be set! - REQUIRED with self . reader ( tiff [ 0 ]) as cog : self . bounds = cog . bounds return self def _get_asset_url ( self , asset : str ) -> str : \"\"\"Validate asset names and return asset's url.\"\"\" if asset not in self . assets : raise InvalidAssetName ( f \" { asset } is not valid\" ) return os . path . join ( self . directory , f \" { asset } .tif\" ) # we have a directoty with \"b1.tif\", \"b2.tif\", \"b3.tif\" with CustomReader ( \"my_dir/\" ) as cr : print ( cr . assets ) tile , mask = cr . tile ( x , y , z , assets = \"b1\" ) > [ \"b1\" , \"b2\" , \"b3\" ] print ( tile . shape ) > ( 3 , 256 , 256 )","title":"Merge assets"},{"location":"#reading-asset-with-a-geojson-polygon","text":"Natively rio-tiler support mostly bbox reading. Using GDALWarpVRT Cutline option, it's possible to read a dataset for a given polygon. from rio_tiler.io import COGReader from rio_tiler.utils import create_cutline from rasterio.features import bounds as featureBounds feat = { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ - 52.6025390625 , 73.86761239709705 ], [ - 52.6025390625 , 73.59679245247814 ], [ - 51.591796875 , 73.60299628304274 ], [ - 51.591796875 , 73.90420357134279 ], [ - 52.4267578125 , 74.0437225981325 ], [ - 52.6025390625 , 73.86761239709705 ] ] ] } } # Get BBOX of the polygon bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Read part of the data (bbox) and use the cutline to mask the data data , mask = cog . part ( bbox , vrt_options = { 'cutline' : cutline }) The previous example uses the .part method but any method that uses the rio_tiler.reader._read function will accept the cutline options. bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Get a preview of the whole geotiff but use the cutline to mask the data data , mask = cog . preview ( vrt_options = { 'cutline' : cutline }) # Read a mercator tile and use the cutline to mask the data data , mask = cog . tile ( 1 , 1 , 1 , vrt_options = { 'cutline' : cutline }) # Get image statistics over a bbox and use the cutline as mask stats = cog . stats ( bounds = bbox , vrt_options = { 'cutline' : cutline })","title":"Reading asset with a GeoJSON Polygon"},{"location":"#partial-reading-on-cloud-hosted-dataset","text":"Rio-tiler perform partial reading on local or distant dataset, which is why it will perform best on Cloud Optimized GeoTIFF (COG). It's important to note that Sentinel-2 scenes hosted on AWS are not in Cloud Optimized format but in JPEG2000 . When performing partial reading of JPEG2000 dataset GDAL (rasterio backend library) will need to make a lot of GET requests and transfer a lot of data. Ref: Do you really want people using your data blog post.","title":"Partial reading on Cloud hosted dataset"},{"location":"#create-an-aws-lambda-package","text":"The easiest way to make sure the package will work on AWS is to use docker FROM lambci/lambda:build-python3.7 ENV LANG = en_US.UTF-8 LC_ALL = en_US.UTF-8 CFLAGS = \"--std=c99\" RUN pip3 install rio-tiler --no-binary numpy -t /tmp/python -U RUN cd /tmp/python && zip -r9q /tmp/package.zip * Ref: vincentsarago/simple-rio-lambda","title":"Create an AWS Lambda package"},{"location":"#mission-specific-tiler","text":"In rio-tiler v2 we choosed to remove the mission specific tilers (Sentinel2, Sentinel1, Landsat8 and CBERS). Those are now in a specific plugin: rio-tiler-pds .","title":"Mission Specific tiler"},{"location":"#plugins","text":"rio-tiler-mvt : Create Mapbox Vector Tile from numpy array (tile/mask) rio-tiler-crs : Create Map Tiles using other TileMatrixSets rio-viz : Visualize Cloud Optimized GeoTIFF in browser locally","title":"Plugins"},{"location":"#implementations","text":"CosmiQ/solaris cogeo-tiler titiler","title":"Implementations"},{"location":"#contribution-development","text":"Issues and pull requests are more than welcome. dev install $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -e . [ dev ] Python3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install","title":"Contribution &amp; Development"},{"location":"#license","text":"See LICENSE.txt","title":"License"},{"location":"#authors","text":"The rio-tiler project was begun at Mapbox and has been transferred in January 2019. See AUTHORS.txt for a listing of individual contributors.","title":"Authors"},{"location":"#changes","text":"See CHANGES.txt .","title":"Changes"},{"location":"colormap/","text":"Colormaps \u00b6 Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data. You can load a colormap with rio_tiler.colormap.get_colormap , and then pass it to rio_tiler.utils.render : from rio_tiler.colormap import cmap from rio_tiler.utils import render colormap = cmap . get ( 'cfastie' ) render ( tile , mask , colormap = colormap ) References \u00b6 Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html cfastie : publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap rplumbo : cogeotiff/rio-tiler!90 schwarzwald : soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html Update images for new colormaps \u00b6 To regenerate these images for new colormaps, update the list of colormaps at the top of scripts/colormap_thumb.py and then run python scripts/colormap_thumb.py","title":"Colormaps"},{"location":"colormap/#colormaps","text":"Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data. You can load a colormap with rio_tiler.colormap.get_colormap , and then pass it to rio_tiler.utils.render : from rio_tiler.colormap import cmap from rio_tiler.utils import render colormap = cmap . get ( 'cfastie' ) render ( tile , mask , colormap = colormap )","title":"Colormaps"},{"location":"colormap/#references","text":"Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html cfastie : publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap rplumbo : cogeotiff/rio-tiler!90 schwarzwald : soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html","title":"References"},{"location":"colormap/#update-images-for-new-colormaps","text":"To regenerate these images for new colormaps, update the list of colormaps at the top of scripts/colormap_thumb.py and then run python scripts/colormap_thumb.py","title":"Update images for new colormaps"},{"location":"dynamic_tiler/","text":"Dynamic Tiling \u00b6 rio-tiler aims to be a lightweight plugin for rasterio whose sole goal is to read a Mercator Tile from a raster dataset. Given that rio-tiler allows for simple, efficient reading of tiles, you can then leverage rio-tiler to create a dynamic tile server to display raster tiles on a web map. There are couple tile servers built on top of rio-tiler: titiler cogeo-tiler cogeo-mosaic-tiler rio-viz Example Application \u00b6 To build a simple dynamic tiling application, we can use FastAPI . Note that titiler uses FastAPI internally, so you might consider using titiler instead of making your own API. Requirements \u00b6 rio-tiler ~= 2.0b fastapi uvicorn Install with pip install fastapi uvicorn 'rio-tiler~=2.0b' app.py \u00b6 \"\"\"rio-tiler tile server.\"\"\" import os from enum import Enum from typing import Any , Dict , List , Optional from urllib.parse import urlencode import uvicorn from fastapi import FastAPI , Path , Query from rasterio.crs import CRS from starlette.background import BackgroundTask from starlette.middleware.cors import CORSMiddleware from starlette.middleware.gzip import GZipMiddleware from starlette.requests import Request from starlette.responses import Response from rio_tiler.profiles import img_profiles from rio_tiler.utils import render from rio_tiler.io import COGReader # From developmentseed/titiler drivers = dict ( jpg = \"JPEG\" , png = \"PNG\" ) mimetype = dict ( png = \"image/png\" , jpg = \"image/jpg\" ,) class ImageType ( str , Enum ): \"\"\"Image Type Enums.\"\"\" png = \"png\" jpg = \"jpg\" class TileResponse ( Response ): \"\"\"Tiler's response.\"\"\" def __init__ ( self , content : bytes , media_type : str , status_code : int = 200 , headers : dict = {}, background : BackgroundTask = None , ttl : int = 3600 , ) -> None : \"\"\"Init tiler response.\"\"\" headers . update ({ \"Content-Type\" : media_type }) if ttl : headers . update ({ \"Cache-Control\" : \"max-age=3600\" }) self . body = self . render ( content ) self . status_code = 200 self . media_type = media_type self . background = background self . init_headers ( headers ) app = FastAPI ( title = \"rio-tiler\" , description = \"A lightweight Cloud Optimized GeoTIFF tile server\" , ) app . add_middleware ( CORSMiddleware , allow_origins = [ \"*\" ], allow_credentials = True , allow_methods = [ \"GET\" ], allow_headers = [ \"*\" ], ) app . add_middleware ( GZipMiddleware , minimum_size = 0 ) responses = { 200 : { \"content\" : { \"image/png\" : {}, \"image/jpg\" : {}}, \"description\" : \"Return an image.\" , } } tile_routes_params : Dict [ str , Any ] = dict ( responses = responses , tags = [ \"tiles\" ], response_class = TileResponse ) @app . get ( \"/ {z} / {x} / {y} \" , ** tile_routes_params ) def tile ( z : int , x : int , y : int , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), ): \"\"\"Handle tiles requests.\"\"\" with COGReader ( url ) as cog : tile , mask = cog . tile ( x , y , z , tilesize = 256 ) format = ImageType . jpg if mask . all () else ImageType . png driver = drivers [ format . value ] options = img_profiles . get ( driver . lower (), {}) img = render ( tile , mask , img_format = driver , ** options ) return TileResponse ( img , media_type = mimetype [ format . value ]) @app . get ( \"/tilejson.json\" , responses = { 200 : { \"description\" : \"Return a tilejson\" }}) def tilejson ( request : Request , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), minzoom : Optional [ int ] = Query ( None , description = \"Overwrite default minzoom.\" ), maxzoom : Optional [ int ] = Query ( None , description = \"Overwrite default maxzoom.\" ), ): \"\"\"Return TileJSON document for a COG.\"\"\" tile_url = request . url_for ( \"tile\" , { \"z\" : \" {z} \" , \"x\" : \" {x} \" , \"y\" : \" {y} \" }) . replace ( \" \\\\ \" , \"\" ) kwargs = dict ( request . query_params ) kwargs . pop ( \"tile_format\" , None ) kwargs . pop ( \"tile_scale\" , None ) kwargs . pop ( \"minzoom\" , None ) kwargs . pop ( \"maxzoom\" , None ) qs = urlencode ( list ( kwargs . items ())) tile_url = f \" { tile_url } ? { qs } \" with COGReader ( url ) as cog : center = list ( cog . center ) if minzoom : center [ - 1 ] = minzoom tjson = { \"bounds\" : cog . bounds , \"center\" : tuple ( center ), \"minzoom\" : minzoom or cog . minzoom , \"maxzoom\" : maxzoom or cog . maxzoom , \"name\" : os . path . basename ( url ), \"tiles\" : [ tile_url ], } return tjson Launch Example \u00b6 Use uvicorn to launch the application. Note that app:app tells uvicorn to call the app function within app.py , so you must be in the same directory as app.py . uvicorn app:app --reload","title":"Dynamic Tiling"},{"location":"dynamic_tiler/#dynamic-tiling","text":"rio-tiler aims to be a lightweight plugin for rasterio whose sole goal is to read a Mercator Tile from a raster dataset. Given that rio-tiler allows for simple, efficient reading of tiles, you can then leverage rio-tiler to create a dynamic tile server to display raster tiles on a web map. There are couple tile servers built on top of rio-tiler: titiler cogeo-tiler cogeo-mosaic-tiler rio-viz","title":"Dynamic Tiling"},{"location":"dynamic_tiler/#example-application","text":"To build a simple dynamic tiling application, we can use FastAPI . Note that titiler uses FastAPI internally, so you might consider using titiler instead of making your own API.","title":"Example Application"},{"location":"dynamic_tiler/#requirements","text":"rio-tiler ~= 2.0b fastapi uvicorn Install with pip install fastapi uvicorn 'rio-tiler~=2.0b'","title":"Requirements"},{"location":"dynamic_tiler/#apppy","text":"\"\"\"rio-tiler tile server.\"\"\" import os from enum import Enum from typing import Any , Dict , List , Optional from urllib.parse import urlencode import uvicorn from fastapi import FastAPI , Path , Query from rasterio.crs import CRS from starlette.background import BackgroundTask from starlette.middleware.cors import CORSMiddleware from starlette.middleware.gzip import GZipMiddleware from starlette.requests import Request from starlette.responses import Response from rio_tiler.profiles import img_profiles from rio_tiler.utils import render from rio_tiler.io import COGReader # From developmentseed/titiler drivers = dict ( jpg = \"JPEG\" , png = \"PNG\" ) mimetype = dict ( png = \"image/png\" , jpg = \"image/jpg\" ,) class ImageType ( str , Enum ): \"\"\"Image Type Enums.\"\"\" png = \"png\" jpg = \"jpg\" class TileResponse ( Response ): \"\"\"Tiler's response.\"\"\" def __init__ ( self , content : bytes , media_type : str , status_code : int = 200 , headers : dict = {}, background : BackgroundTask = None , ttl : int = 3600 , ) -> None : \"\"\"Init tiler response.\"\"\" headers . update ({ \"Content-Type\" : media_type }) if ttl : headers . update ({ \"Cache-Control\" : \"max-age=3600\" }) self . body = self . render ( content ) self . status_code = 200 self . media_type = media_type self . background = background self . init_headers ( headers ) app = FastAPI ( title = \"rio-tiler\" , description = \"A lightweight Cloud Optimized GeoTIFF tile server\" , ) app . add_middleware ( CORSMiddleware , allow_origins = [ \"*\" ], allow_credentials = True , allow_methods = [ \"GET\" ], allow_headers = [ \"*\" ], ) app . add_middleware ( GZipMiddleware , minimum_size = 0 ) responses = { 200 : { \"content\" : { \"image/png\" : {}, \"image/jpg\" : {}}, \"description\" : \"Return an image.\" , } } tile_routes_params : Dict [ str , Any ] = dict ( responses = responses , tags = [ \"tiles\" ], response_class = TileResponse ) @app . get ( \"/ {z} / {x} / {y} \" , ** tile_routes_params ) def tile ( z : int , x : int , y : int , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), ): \"\"\"Handle tiles requests.\"\"\" with COGReader ( url ) as cog : tile , mask = cog . tile ( x , y , z , tilesize = 256 ) format = ImageType . jpg if mask . all () else ImageType . png driver = drivers [ format . value ] options = img_profiles . get ( driver . lower (), {}) img = render ( tile , mask , img_format = driver , ** options ) return TileResponse ( img , media_type = mimetype [ format . value ]) @app . get ( \"/tilejson.json\" , responses = { 200 : { \"description\" : \"Return a tilejson\" }}) def tilejson ( request : Request , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), minzoom : Optional [ int ] = Query ( None , description = \"Overwrite default minzoom.\" ), maxzoom : Optional [ int ] = Query ( None , description = \"Overwrite default maxzoom.\" ), ): \"\"\"Return TileJSON document for a COG.\"\"\" tile_url = request . url_for ( \"tile\" , { \"z\" : \" {z} \" , \"x\" : \" {x} \" , \"y\" : \" {y} \" }) . replace ( \" \\\\ \" , \"\" ) kwargs = dict ( request . query_params ) kwargs . pop ( \"tile_format\" , None ) kwargs . pop ( \"tile_scale\" , None ) kwargs . pop ( \"minzoom\" , None ) kwargs . pop ( \"maxzoom\" , None ) qs = urlencode ( list ( kwargs . items ())) tile_url = f \" { tile_url } ? { qs } \" with COGReader ( url ) as cog : center = list ( cog . center ) if minzoom : center [ - 1 ] = minzoom tjson = { \"bounds\" : cog . bounds , \"center\" : tuple ( center ), \"minzoom\" : minzoom or cog . minzoom , \"maxzoom\" : maxzoom or cog . maxzoom , \"name\" : os . path . basename ( url ), \"tiles\" : [ tile_url ], } return tjson","title":"app.py"},{"location":"dynamic_tiler/#launch-example","text":"Use uvicorn to launch the application. Note that app:app tells uvicorn to call the app function within app.py , so you must be in the same directory as app.py . uvicorn app:app --reload","title":"Launch Example"},{"location":"mosaic/","text":"Using rio-tiler with Mosaics \u00b6 The rio-tiler-mosaic library has been moved into rio-tiler . The goal of the rio_tiler.mosaic module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest. Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the rio-tiler.mosaic module provides pixel selection methods which define how to handle these cases for each pixel: First : select value from the first non-missing asset Highest : loop though all the assets and return the highest value Lowest : loop though all the assets and return the lowest value Mean : compute the mean value of the whole stack Median : compute the median value of the whole stack API \u00b6 rio_tiler.mosaic.mosaic_reader(assets, tiler, *args* pixel_selection=None, chunk_size=None, Threads=10, **kwargs) Inputs: assets : list, tuple of rio-tiler compatible assets (url or sceneid) tiler: Callable that returns a tuple of numpy.array (e.g tile, mask = rio_tiler.reader.tile(x, y, z, **kwargs) ) *args: tiler specific arguments. pixel_selection : optional pixel selection algorithm (default: \"first\"). chunk_size: optional, control the number of asset to process per loop. **kwargs: tiler specific keyword arguments. Returns: - (tile, mask), assets_used : tuple of ndarray Return (tile and mask) data and the list of used assets. Examples \u00b6 from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] tile = ( 1000 , 1000 , 9 ) x , y , z = tile # Use Default First value method mosaic_reader ( assets , tiler , x , y , z ) # Use Highest value: defaults.HighestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . HighestMethod () ) # Use Lowest value: defaults.LowestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . LowestMethod () ) The MosaicMethod interface \u00b6 the rio_tiler.mosaic.methods.base.MosaicMethodBase class defines an abstract interface for all pixel selection methods allowed by rio_tiler.mosaic.mosaic_reader . its methods and properties are: is_done : property, returns a boolean indicating if the process is done filling the tile data : property, returns the output tile and mask numpy arrays feed(tile: numpy.ma.ndarray) : method, update the tile The MosaicMethodBase class is not intended to be used directly but as an abstract base class, a template for concrete implementations. Writing your own Pixel Selection method \u00b6 The rules for writing your own pixel selection algorithm class are as follows: Must inherit from MosaicMethodBase Must provide concrete implementations of all the above methods. See rio_tiler.mosaic.methods.defaults classes for examples. Smart Multi-Threading \u00b6 When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, rio_tiler.mosaic.mosaic_reader is fetching the tiles in parallel (threads) but to limit the number of files we also embeded the fetching in a loop (creating 2 level of processing): assets = [ \"1.tif\" , \"2.tif\" , \"3.tif\" , \"4.tif\" , \"5.tif\" , \"6.tif\" ] # 1st level loop - Creates chuncks of assets for chunks in _chunks ( assets , chunk_size ): # 2nd level loop - Uses threads for process each `chunck` with futures . ThreadPoolExecutor ( max_workers = max_threads ) as executor : future_tasks = [( executor . submit ( _tiler , asset ), asset ) for asset in chunks ] By default the chunck_size is equal to the number or threads (or the number of assets if no threads=0) More on threading \u00b6 The number of threads used can be set in the function call with the threads= options. By default it will be equal to multiprocessing.cpu_count() * 5 or to the MAX_THREADS environment variable. In some case, threading can slow down your application. You can set threads to 0 or 1 to run the tiler in a loop without using a ThreadPool. Benchmark: --------------------------------- benchmark '1images': 6 tests --------------------------------- Name (time in ms) Min Max Mean Median ------------------------------------------------------------------------------------------------ 1images-0threads 64.3108 (1.0) 66.9192 (1.0) 65.0202 (1.0) 64.9370 (1.0) 1images-4threads 69.0893 (1.07) 70.9919 (1.06) 69.6718 (1.07) 69.5102 (1.07) 1images-1threads 69.4884 (1.08) 71.8967 (1.07) 70.0853 (1.08) 69.9804 (1.08) 1images-5threads 69.5552 (1.08) 75.5498 (1.13) 71.7882 (1.10) 70.9849 (1.09) 1images-3threads 69.7684 (1.08) 74.4098 (1.11) 70.6282 (1.09) 70.2353 (1.08) 1images-2threads 69.9258 (1.09) 73.8798 (1.10) 70.8861 (1.09) 70.3682 (1.08) ------------------------------------------------------------------------------------------------ ----------------------------------- benchmark '5images': 6 tests ----------------------------------- Name (time in ms) Min Max Mean Median ---------------------------------------------------------------------------------------------------- 5images-5threads 104.1609 (1.0) 123.4442 (1.0) 110.4130 (1.0) 110.0683 (1.0) 5images-4threads 160.0952 (1.54) 170.7994 (1.38) 163.6062 (1.48) 161.8923 (1.47) 5images-3threads 161.2354 (1.55) 172.0363 (1.39) 165.1222 (1.50) 164.6513 (1.50) 5images-2threads 214.2413 (2.06) 220.7737 (1.79) 217.7740 (1.97) 217.9166 (1.98) 5images-0threads 228.2062 (2.19) 242.9397 (1.97) 231.9848 (2.10) 229.2843 (2.08) 5images-1threads 248.6630 (2.39) 251.8809 (2.04) 250.5195 (2.27) 251.2667 (2.28) ---------------------------------------------------------------------------------------------------- ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838 As mentioned in #207, using ThreadPool with 1 thread is always slower than not using thread.","title":"Mosaic"},{"location":"mosaic/#using-rio-tiler-with-mosaics","text":"The rio-tiler-mosaic library has been moved into rio-tiler . The goal of the rio_tiler.mosaic module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest. Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the rio-tiler.mosaic module provides pixel selection methods which define how to handle these cases for each pixel: First : select value from the first non-missing asset Highest : loop though all the assets and return the highest value Lowest : loop though all the assets and return the lowest value Mean : compute the mean value of the whole stack Median : compute the median value of the whole stack","title":"Using rio-tiler with Mosaics"},{"location":"mosaic/#api","text":"rio_tiler.mosaic.mosaic_reader(assets, tiler, *args* pixel_selection=None, chunk_size=None, Threads=10, **kwargs) Inputs: assets : list, tuple of rio-tiler compatible assets (url or sceneid) tiler: Callable that returns a tuple of numpy.array (e.g tile, mask = rio_tiler.reader.tile(x, y, z, **kwargs) ) *args: tiler specific arguments. pixel_selection : optional pixel selection algorithm (default: \"first\"). chunk_size: optional, control the number of asset to process per loop. **kwargs: tiler specific keyword arguments. Returns: - (tile, mask), assets_used : tuple of ndarray Return (tile and mask) data and the list of used assets.","title":"API"},{"location":"mosaic/#examples","text":"from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] tile = ( 1000 , 1000 , 9 ) x , y , z = tile # Use Default First value method mosaic_reader ( assets , tiler , x , y , z ) # Use Highest value: defaults.HighestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . HighestMethod () ) # Use Lowest value: defaults.LowestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . LowestMethod () )","title":"Examples"},{"location":"mosaic/#the-mosaicmethod-interface","text":"the rio_tiler.mosaic.methods.base.MosaicMethodBase class defines an abstract interface for all pixel selection methods allowed by rio_tiler.mosaic.mosaic_reader . its methods and properties are: is_done : property, returns a boolean indicating if the process is done filling the tile data : property, returns the output tile and mask numpy arrays feed(tile: numpy.ma.ndarray) : method, update the tile The MosaicMethodBase class is not intended to be used directly but as an abstract base class, a template for concrete implementations.","title":"The MosaicMethod interface"},{"location":"mosaic/#writing-your-own-pixel-selection-method","text":"The rules for writing your own pixel selection algorithm class are as follows: Must inherit from MosaicMethodBase Must provide concrete implementations of all the above methods. See rio_tiler.mosaic.methods.defaults classes for examples.","title":"Writing your own Pixel Selection method"},{"location":"mosaic/#smart-multi-threading","text":"When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, rio_tiler.mosaic.mosaic_reader is fetching the tiles in parallel (threads) but to limit the number of files we also embeded the fetching in a loop (creating 2 level of processing): assets = [ \"1.tif\" , \"2.tif\" , \"3.tif\" , \"4.tif\" , \"5.tif\" , \"6.tif\" ] # 1st level loop - Creates chuncks of assets for chunks in _chunks ( assets , chunk_size ): # 2nd level loop - Uses threads for process each `chunck` with futures . ThreadPoolExecutor ( max_workers = max_threads ) as executor : future_tasks = [( executor . submit ( _tiler , asset ), asset ) for asset in chunks ] By default the chunck_size is equal to the number or threads (or the number of assets if no threads=0)","title":"Smart Multi-Threading"},{"location":"mosaic/#more-on-threading","text":"The number of threads used can be set in the function call with the threads= options. By default it will be equal to multiprocessing.cpu_count() * 5 or to the MAX_THREADS environment variable. In some case, threading can slow down your application. You can set threads to 0 or 1 to run the tiler in a loop without using a ThreadPool. Benchmark: --------------------------------- benchmark '1images': 6 tests --------------------------------- Name (time in ms) Min Max Mean Median ------------------------------------------------------------------------------------------------ 1images-0threads 64.3108 (1.0) 66.9192 (1.0) 65.0202 (1.0) 64.9370 (1.0) 1images-4threads 69.0893 (1.07) 70.9919 (1.06) 69.6718 (1.07) 69.5102 (1.07) 1images-1threads 69.4884 (1.08) 71.8967 (1.07) 70.0853 (1.08) 69.9804 (1.08) 1images-5threads 69.5552 (1.08) 75.5498 (1.13) 71.7882 (1.10) 70.9849 (1.09) 1images-3threads 69.7684 (1.08) 74.4098 (1.11) 70.6282 (1.09) 70.2353 (1.08) 1images-2threads 69.9258 (1.09) 73.8798 (1.10) 70.8861 (1.09) 70.3682 (1.08) ------------------------------------------------------------------------------------------------ ----------------------------------- benchmark '5images': 6 tests ----------------------------------- Name (time in ms) Min Max Mean Median ---------------------------------------------------------------------------------------------------- 5images-5threads 104.1609 (1.0) 123.4442 (1.0) 110.4130 (1.0) 110.0683 (1.0) 5images-4threads 160.0952 (1.54) 170.7994 (1.38) 163.6062 (1.48) 161.8923 (1.47) 5images-3threads 161.2354 (1.55) 172.0363 (1.39) 165.1222 (1.50) 164.6513 (1.50) 5images-2threads 214.2413 (2.06) 220.7737 (1.79) 217.7740 (1.97) 217.9166 (1.98) 5images-0threads 228.2062 (2.19) 242.9397 (1.97) 231.9848 (2.10) 229.2843 (2.08) 5images-1threads 248.6630 (2.39) 251.8809 (2.04) 250.5195 (2.27) 251.2667 (2.28) ---------------------------------------------------------------------------------------------------- ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838 As mentioned in #207, using ThreadPool with 1 thread is always slower than not using thread.","title":"More on threading"},{"location":"v2_migration/","text":"rio-tiler 1.0 to 2.0 migration \u00b6 rio-tiler version 2.0 introduced many breaking changes . This document aims to help with migrating your code to use rio-tiler 2.0. Python 3 only \u00b6 First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead . For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.5 or later is required. If you need help moving from Python 2 to 3 check out the official transition documentation . Type hints \u00b6 As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools. This does not require any changes to your code as long as you're using Python 3.6+. For more information see: fastapi.tiangolo.com/python-types/ kishstats.com/python/2019/01/07/python-type-hinting.html mypy.readthedocs.io/en/stable/cheat_sheet_py3.html Typing example: def get_vrt_transform ( src_dst : Union [ DatasetReader , DatasetWriter , WarpedVRT ], bounds : Tuple [ float , float , float , float ], dst_crs : CRS = constants . WEB_MERCATOR_CRS , ) -> Tuple [ Affine , int , int ]: Rasterio >= 1.1.3 \u00b6 Rasterio 1.1.3 or newer is required. Recent changes in rasterio makes masking more reliable. New rio_tiler.io submodules \u00b6 We created revised submodules for working with COGs and STAC: rio_tiler.io.cogeo is a modified version of the previous rio_tiler.main.tile . rio_tiler.io.stac is a new module to work with SpatioTemporal Asset Catalogs (STAC) . We now support reading files through a ContextManager to enable accessing the source rasterio dataset. # v1 from rio_tiler.main import tile as cogTiler tile , mask = cogTiler ( 'my_tif.tif' , 691559 , 956905 , 21 , tilesize = 256 ) # v2 from rio_tiler.io import COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( cog . dataset ) # rasterio dataset (returned by rasterio.open()) print ( cog . dataset . meta ) # rasterio metadata print ( cog . bounds ) # WGS84 bounds print ( cog . colormap ) # internal colormap Expression support is now directly available in the COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , expression = \"b1/b2\" ) COGReader description \u00b6 class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\" Internal API: rio_tiler.reader \u00b6 Internal tile/data reading functions have been refactored and moved to a new rio_tiler.reader submodule. tile \u00b6 In rio_tiler==1 most of the magic was happening in rio_tiler.utils._tile_read . In rio_tiler==2 this function is now split in two, rio_tiler.reader.part and rio_tiler_reader._read , to reduce code reutilisation and to make the code more robust. The part function now takes height and width instead of a unique tilesize to specify the output array size. To ease the transition we added a rio_tiler.reader.tile function. Note: The new rio_tiler.reader.part function enables to perform non-squared data cropping by passing output width and height (instead of just tilesize). # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : # get tile bounds and read raster mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) # Will check if tile is valid # Or with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . reader . part ( src_dst , tile_bounds , 256 , 256 ) Options changes - tile_edge_padding -> padding , and set to 0 by default - minimum_tile_cover -> minimum_overlap - unscale ( New ): add ability to apply scale and offset to the data (Default: False) # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , tile_edge_padding = 4 , minimum_tile_cover = 0.3 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 , padding = 4 , minimum_overlap = 0.3 ) Alpha band \u00b6 Since the first version, rio-tiler returns a tuple of (data, mask) in most of the reading function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126 , where a user gets a 4 bands data array + a mask (instead of 3 bands + mask). In rio-tiler=2. , when no indexes options are passed, we remove the alpha channel from the output data array. # v1 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , indexes = ( 1 , 2 , 3 )) # v2 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : # because rio-tiler will remove the alpha band we don't need to use the indexes option t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) metadata \u00b6 rio_tiler.utils._raster_get_stats has been replaced by rio_tiler.reader.metadata which uses the new reader.part and reader.preview functions. Meaning that now you can get metadata for a specific area by passing a bbox. To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use only the max_size options, meaning the overview_level options have been removed (at least for version 2.0.0). # v1 import rio_tiler with rasterio . open ( \"my_tif.tif\" ) as src_dst : meta = rio_tiler . utils . _raster_get_stats ( src_dst ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) Options changes - removed histogram_bins and histogram_range which should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - removed overview_level - added bounds Output The output has also been updated. The new metadata output doesn't return min/max zoom and bounds is return in WGS84 by default. # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . utils . _raster_get_stats ( src_dst ) > { \"bounds\" : { \"value\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"crs\" : \"EPSG:4326\" }, \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_descriptions\" : [ [ 1 , \"band1\" ] ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 17 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.418616203143802 , \"histogram\" : [ [ ... ], [ ... ] ] } } } # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) > { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } }, \"nodata_type\" : \"Nodata\" , \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], \"2\" : [ 148 , 56 , 112 , 255 ], ... } } colormaps \u00b6 In addition to a new colormap specific submodule ( rio_tiler.colormap ), in rio-tiler==2 , colormaps are now RGBA values. We also removed PIL colormap compatibility. # v1 cmap = rio_tiler . utils . get_colormap ( \"viridis\" , format = \"gdal\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 ] # v2 cmap = rio_tiler . colormap . get_colormap ( \"viridis\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 , 255 ] render \u00b6 In rio-tiler==1. * to create an image blob from an array we used the rio_tiler.utils.array_to_image function. We have renamed and slightly refactored the function but it works the same. # v1 img = rio_tiler . utils . array_to_image ( tile , mask , img_format = \"PNG\" ) # v2 img = rio_tiler . utils . render ( tile , mask , img_format = \"PNG\" ) Mission specific changes \u00b6 Mission-specific tilers have been moved to the rio-tiler-pds package. Each rio_tiler.io.{mission} scene id parser (e.g cbers_parser) has been refactored and now return AWS S3 path information. rio_tiler . io . landsat8 . landsat_parser ( \"LC08_L1TP_016037_20170813_20170814_01_RT\" )) { \"sensor\" : \"C\" , \"satellite\" : \"08\" , \"processingCorrectionLevel\" : \"L1TP\" , \"path\" : \"016\" , \"row\" : \"037\" , \"acquisitionYear\" : \"2017\" , \"acquisitionMonth\" : \"08\" , \"acquisitionDay\" : \"13\" , \"processingYear\" : \"2017\" , \"processingMonth\" : \"08\" , \"processingDay\" : \"14\" , \"collectionNumber\" : \"01\" , \"collectionCategory\" : \"RT\" , \"scene\" : \"LC08_L1TP_016037_20170813_20170814_01_RT\" , \"date\" : \"2017-08-13\" , --> \"scheme\" : \"s3\" , --> \"bucket\" : \"landsat-pds\" , --> \"prefix\" : \"c1/L8/016/037/LC08_L1TP_016037_20170813_20170814_01_RT\" }","title":"v2 Migration"},{"location":"v2_migration/#rio-tiler-10-to-20-migration","text":"rio-tiler version 2.0 introduced many breaking changes . This document aims to help with migrating your code to use rio-tiler 2.0.","title":"rio-tiler 1.0 to 2.0 migration"},{"location":"v2_migration/#python-3-only","text":"First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead . For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.5 or later is required. If you need help moving from Python 2 to 3 check out the official transition documentation .","title":"Python 3 only"},{"location":"v2_migration/#type-hints","text":"As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools. This does not require any changes to your code as long as you're using Python 3.6+. For more information see: fastapi.tiangolo.com/python-types/ kishstats.com/python/2019/01/07/python-type-hinting.html mypy.readthedocs.io/en/stable/cheat_sheet_py3.html Typing example: def get_vrt_transform ( src_dst : Union [ DatasetReader , DatasetWriter , WarpedVRT ], bounds : Tuple [ float , float , float , float ], dst_crs : CRS = constants . WEB_MERCATOR_CRS , ) -> Tuple [ Affine , int , int ]:","title":"Type hints"},{"location":"v2_migration/#rasterio-113","text":"Rasterio 1.1.3 or newer is required. Recent changes in rasterio makes masking more reliable.","title":"Rasterio &gt;= 1.1.3"},{"location":"v2_migration/#new-rio_tilerio-submodules","text":"We created revised submodules for working with COGs and STAC: rio_tiler.io.cogeo is a modified version of the previous rio_tiler.main.tile . rio_tiler.io.stac is a new module to work with SpatioTemporal Asset Catalogs (STAC) . We now support reading files through a ContextManager to enable accessing the source rasterio dataset. # v1 from rio_tiler.main import tile as cogTiler tile , mask = cogTiler ( 'my_tif.tif' , 691559 , 956905 , 21 , tilesize = 256 ) # v2 from rio_tiler.io import COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( cog . dataset ) # rasterio dataset (returned by rasterio.open()) print ( cog . dataset . meta ) # rasterio metadata print ( cog . bounds ) # WGS84 bounds print ( cog . colormap ) # internal colormap Expression support is now directly available in the COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , expression = \"b1/b2\" )","title":"New rio_tiler.io submodules"},{"location":"v2_migration/#cogreader-description","text":"class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\"","title":"COGReader description"},{"location":"v2_migration/#internal-api-rio_tilerreader","text":"Internal tile/data reading functions have been refactored and moved to a new rio_tiler.reader submodule.","title":"Internal API: rio_tiler.reader"},{"location":"v2_migration/#tile","text":"In rio_tiler==1 most of the magic was happening in rio_tiler.utils._tile_read . In rio_tiler==2 this function is now split in two, rio_tiler.reader.part and rio_tiler_reader._read , to reduce code reutilisation and to make the code more robust. The part function now takes height and width instead of a unique tilesize to specify the output array size. To ease the transition we added a rio_tiler.reader.tile function. Note: The new rio_tiler.reader.part function enables to perform non-squared data cropping by passing output width and height (instead of just tilesize). # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : # get tile bounds and read raster mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) # Will check if tile is valid # Or with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . reader . part ( src_dst , tile_bounds , 256 , 256 ) Options changes - tile_edge_padding -> padding , and set to 0 by default - minimum_tile_cover -> minimum_overlap - unscale ( New ): add ability to apply scale and offset to the data (Default: False) # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , tile_edge_padding = 4 , minimum_tile_cover = 0.3 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 , padding = 4 , minimum_overlap = 0.3 )","title":"tile"},{"location":"v2_migration/#alpha-band","text":"Since the first version, rio-tiler returns a tuple of (data, mask) in most of the reading function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126 , where a user gets a 4 bands data array + a mask (instead of 3 bands + mask). In rio-tiler=2. , when no indexes options are passed, we remove the alpha channel from the output data array. # v1 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , indexes = ( 1 , 2 , 3 )) # v2 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : # because rio-tiler will remove the alpha band we don't need to use the indexes option t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 )","title":"Alpha band"},{"location":"v2_migration/#metadata","text":"rio_tiler.utils._raster_get_stats has been replaced by rio_tiler.reader.metadata which uses the new reader.part and reader.preview functions. Meaning that now you can get metadata for a specific area by passing a bbox. To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use only the max_size options, meaning the overview_level options have been removed (at least for version 2.0.0). # v1 import rio_tiler with rasterio . open ( \"my_tif.tif\" ) as src_dst : meta = rio_tiler . utils . _raster_get_stats ( src_dst ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) Options changes - removed histogram_bins and histogram_range which should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - removed overview_level - added bounds Output The output has also been updated. The new metadata output doesn't return min/max zoom and bounds is return in WGS84 by default. # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . utils . _raster_get_stats ( src_dst ) > { \"bounds\" : { \"value\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"crs\" : \"EPSG:4326\" }, \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_descriptions\" : [ [ 1 , \"band1\" ] ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 17 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.418616203143802 , \"histogram\" : [ [ ... ], [ ... ] ] } } } # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) > { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } }, \"nodata_type\" : \"Nodata\" , \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], \"2\" : [ 148 , 56 , 112 , 255 ], ... } }","title":"metadata"},{"location":"v2_migration/#colormaps","text":"In addition to a new colormap specific submodule ( rio_tiler.colormap ), in rio-tiler==2 , colormaps are now RGBA values. We also removed PIL colormap compatibility. # v1 cmap = rio_tiler . utils . get_colormap ( \"viridis\" , format = \"gdal\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 ] # v2 cmap = rio_tiler . colormap . get_colormap ( \"viridis\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 , 255 ]","title":"colormaps"},{"location":"v2_migration/#render","text":"In rio-tiler==1. * to create an image blob from an array we used the rio_tiler.utils.array_to_image function. We have renamed and slightly refactored the function but it works the same. # v1 img = rio_tiler . utils . array_to_image ( tile , mask , img_format = \"PNG\" ) # v2 img = rio_tiler . utils . render ( tile , mask , img_format = \"PNG\" )","title":"render"},{"location":"v2_migration/#mission-specific-changes","text":"Mission-specific tilers have been moved to the rio-tiler-pds package. Each rio_tiler.io.{mission} scene id parser (e.g cbers_parser) has been refactored and now return AWS S3 path information. rio_tiler . io . landsat8 . landsat_parser ( \"LC08_L1TP_016037_20170813_20170814_01_RT\" )) { \"sensor\" : \"C\" , \"satellite\" : \"08\" , \"processingCorrectionLevel\" : \"L1TP\" , \"path\" : \"016\" , \"row\" : \"037\" , \"acquisitionYear\" : \"2017\" , \"acquisitionMonth\" : \"08\" , \"acquisitionDay\" : \"13\" , \"processingYear\" : \"2017\" , \"processingMonth\" : \"08\" , \"processingDay\" : \"14\" , \"collectionNumber\" : \"01\" , \"collectionCategory\" : \"RT\" , \"scene\" : \"LC08_L1TP_016037_20170813_20170814_01_RT\" , \"date\" : \"2017-08-13\" , --> \"scheme\" : \"s3\" , --> \"bucket\" : \"landsat-pds\" , --> \"prefix\" : \"c1/L8/016/037/LC08_L1TP_016037_20170813_20170814_01_RT\" }","title":"Mission specific changes"}]}