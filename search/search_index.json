{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rio-tiler \u00b6 Rasterio plugin to read mercator tiles from Cloud Optimized GeoTIFF. Install \u00b6 You can install rio-tiler using pip $ pip install -U pip $ pip install rio-tiler --pre # version 2.0 is in development or install from source: $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -U pip $ pip install -e . Usage \u00b6 The rio_tiler module can create mercator tiles from any raster source supported by Rasterio/GDAL (i.e. local files, http, s3, gcs etc.). Additional method are availables (see COGReader ) Read a tile from a file \u00b6 from rio_tiler.io import COGReader with COGReader ( \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) print ( mask . shape ) > ( 256 , 256 ) Render the array as an image (PNG/JPEG) \u00b6 from rio_tiler.utils import render buffer = render ( tile , mask = mask ) # this returns a buffer (PNG by default) Rescale non-byte data and/or apply colormap from rio_tiler.colormap import cmap from rio_tiler.utils import linear_rescale # Rescale the tile array only where mask is valid and cast it to byte tile = numpy . where ( mask , linear_rescale ( tile , in_range = ( 0 , 1000 ), out_range = [ 0 , 255 ]), 0 ) . astype ( numpy . uint8 ) cm = cmap . get ( \"viridis\" ) buffer = render ( tile , mask = mask , colormap = cm ) Use creation options to match mapnik defaults. from rio_tiler.utils import render from rio_tiler.profiles import img_profiles options = img_profiles . get ( \"webp\" ) buffer = render ( tile , mask = mask , img_format = \"webp\" , ** options ) Write image to file with open ( \"my.png\" , \"wb\" ) as f : f . write ( buffer ) COGReader \u00b6 class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. info: dict General information about the COG (datatype, indexes, ...) stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\" Properties \u00b6 dataset : Return the rasterio dataset colormap : Return the dataset's internal colormap minzoom : Return minimum Mercator Zoom maxzoom : Return maximum Mercator Zoom bounds : Return the dataset bounds in WGS84 center : Return the center of the dataset + minzoom spatial_info : Return the bounds, center and zoom infos Methods \u00b6 tile() : Read map tile from a raster with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" s ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , expression = \"B1/B2\" ) part() : Read part of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 )) # Limit output size (default is set to 1024) with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = 2000 ) # Read high resolution with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = None ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), expression = \"B1/B2\" ) preview() : Read a preview of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview () # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( expression = \"B1+2,B1*4\" ) point() : Read point value of a raster with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 )) # With indexes with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , indexes = 1 )) [ 1 ] # With expression with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , expression = \"B1+2,B1*4\" )) [ 3 , 4 ] info() : Return simple metadata about the dataset with COGReader ( \"myfile.tif\" ) as cog : print ( cog . info ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } } stats() : Return image statistics (Min/Max/Stdev) with COGReader ( \"myfile.tif\" ) as cog : print ( cog . stats ()) { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } metadata() : Return COG info + statistics with COGReader ( \"myfile.tif\" ) as cog : print ( cog . metadata ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } \"statistics\" : { 1 : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } } Global Options \u00b6 COGReader accept several options which will be forwarded to the rio_tiler.reader._read function (low level function accessing the data): - nodata : Overwrite the nodata value (or set if not present) - unscale : Apply internal rescaling factors - vrt_options : Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions ) Note: Those options could already be passed on each method call. with COGReader ( \"my_cog.tif\" , nodata = 0 ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 ) # is equivalent to with COGReader ( \"my_cog.tif\" ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 , nodata = 0 ) STACReader \u00b6 In rio-tiler v2, we added a rio_tiler.io.STACReader to allow tile/metadata fetching of assets withing a STAC item. The STACReader objects has the same properties/methods as the COGReader. from typing import Dict from rio_tiler.io import STACReader with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : print ( stac . bounds ) print ( stac . assets ) > [ 23.293255090449595 , 31.505183020453355 , 24.296453548295318 , 32.51147809805106 ] > [ 'overview' , 'visual' , 'B01' , 'B02' , 'B03' , 'B04' , 'B05' , 'B06' , 'B07' , 'B08' , 'B8A' , 'B09' , 'B11' , 'B12' , 'AOT' , 'WVP' , 'SCL' ] # Name of assets to read assets = [ \"B01\" , \"B02\" ] with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , assets = assets ) print ( tile . shape ) > ( 2 , 256 , 256 ) # With expression with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , expression = \"B01/B02\" ) print ( tile . shape ) > ( 1 , 256 , 256 ) Note: STACReader is based on rio_tiler.io.base.MultiBaseReader class. Working with multiple assets \u00b6 Mosaic \u00b6 Starting in rio-tiler 2.0, we've transfered the rio-tiler-mosaic plugin to be a rio-tiler submodule. from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , 1 , 1 , 1 ) Learn more about rio_tiler.mosaic in docs/mosaic.md . Notebook: WorkingWithMosaic Merge assets \u00b6 rio_tiler.io.cogeo submodule has multi_* functions (tile, part, preview, point, metadata, info, stats) allowing to fetch and merge info/data from multiple dataset (think about multiple bands stored in separated files). from typing import Dict from rio_tiler.io.cogeo import multi_tile assets = [ \"b1.tif\" , \"b2.tif\" , \"b3.tif\" ] tile , mask = multi_tile ( assets , x , y , z , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) # Others metadata = multi_info ( assets ) stats = multi_stats ( assets , pmin = 2 , pmax = 98 , ... ) metadata = multi_metadata ( assets , pmin = 2 , pmax = 98 , ... ) values = multi_points ( assets , lon , lat , ... ) data , mask = multi_part ( assets , bbox , ... ) data , mask = multi_preview ( assets , ... ) You can also use rio_tiler.io.base.MultiBaseReader to build a custom asset reader: import attr from rio_tiler.io.base import MultiBaseReader from rio_tiler.io import COGReader , BaseReader # CustomReader is a subclass of MultiBaseReader. # To ease the creation of the class and because MultiBaseReader is built with `attr` # we also need to add the `@attr.s` wrapper on top of our custom class. @attr . s class CustomReader ( MultiBaseReader ): directory : str = attr . ib () # required arg reader : Type [ BaseReader ] = attr . ib ( default = COGReader ) # the default reader is COGReader def __enter__ ( self ): # List files in directory dirs = os . listdir ( self . directory ) # get list of tifs tiff = [ f for f in dirs if f . endswith ( \".tif\" )] # create list of assets names - REQUIRED self . assets = [ os . path . basename ( f ) . split ( \".\" )[ 0 ] for f in tiff ] # `self.bounds` needs to be set! - REQUIRED with self . reader ( tiff [ 0 ]) as cog : self . bounds = cog . bounds return self def _get_asset_url ( self , asset : str ) -> str : \"\"\"Validate asset names and return asset's url.\"\"\" if asset not in self . assets : raise InvalidAssetName ( f \" { asset } is not valid\" ) return os . path . join ( self . directory , f \" { asset } .tif\" ) # we have a directoty with \"b1.tif\", \"b2.tif\", \"b3.tif\" with CustomReader ( \"my_dir/\" ) as cr : print ( cr . assets ) tile , mask = cr . tile ( x , y , z , assets = \"b1\" ) > [ \"b1\" , \"b2\" , \"b3\" ] print ( tile . shape ) > ( 3 , 256 , 256 ) Reading asset with a GeoJSON Polygon \u00b6 Natively rio-tiler support mostly bbox reading. Using GDALWarpVRT Cutline option, it's possible to read a dataset for a given polygon. from rio_tiler.io import COGReader from rio_tiler.utils import create_cutline from rasterio.features import bounds as featureBounds feat = { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ - 52.6025390625 , 73.86761239709705 ], [ - 52.6025390625 , 73.59679245247814 ], [ - 51.591796875 , 73.60299628304274 ], [ - 51.591796875 , 73.90420357134279 ], [ - 52.4267578125 , 74.0437225981325 ], [ - 52.6025390625 , 73.86761239709705 ] ] ] } } # Get BBOX of the polygon bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Read part of the data (bbox) and use the cutline to mask the data data , mask = cog . part ( bbox , vrt_options = { 'cutline' : cutline }) The previous example uses the .part method but any method that uses the rio_tiler.reader._read function will accept the cutline options. bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Get a preview of the whole geotiff but use the cutline to mask the data data , mask = cog . preview ( vrt_options = { 'cutline' : cutline }) # Read a mercator tile and use the cutline to mask the data data , mask = cog . tile ( 1 , 1 , 1 , vrt_options = { 'cutline' : cutline }) # Get image statistics over a bbox and use the cutline as mask stats = cog . stats ( bounds = bbox , vrt_options = { 'cutline' : cutline }) Partial reading on Cloud hosted dataset \u00b6 Rio-tiler perform partial reading on local or distant dataset, which is why it will perform best on Cloud Optimized GeoTIFF (COG). It's important to note that Sentinel-2 scenes hosted on AWS are not in Cloud Optimized format but in JPEG2000 . When performing partial reading of JPEG2000 dataset GDAL (rasterio backend library) will need to make a lot of GET requests and transfer a lot of data. Ref: Do you really want people using your data blog post. Create an AWS Lambda package \u00b6 The easiest way to make sure the package will work on AWS is to use docker FROM lambci/lambda:build-python3.7 ENV LANG = en_US.UTF-8 LC_ALL = en_US.UTF-8 CFLAGS = \"--std=c99\" RUN pip3 install rio-tiler --no-binary numpy -t /tmp/python -U RUN cd /tmp/python && zip -r9q /tmp/package.zip * Ref: vincentsarago/simple-rio-lambda Mission Specific tiler \u00b6 In rio-tiler v2 we choosed to remove the mission specific tilers (Sentinel2, Sentinel1, Landsat8 and CBERS). Those are now in a specific plugin: rio-tiler-pds . Plugins \u00b6 rio-tiler-mvt : Create Mapbox Vector Tile from numpy array (tile/mask) rio-tiler-crs : Create Map Tiles using other TileMatrixSets rio-viz : Visualize Cloud Optimized GeoTIFF in browser locally Implementations \u00b6 CosmiQ/solaris cogeo-tiler titiler Contribution & Development \u00b6 Issues and pull requests are more than welcome. dev install $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -e . [ dev ] Python3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install License \u00b6 See LICENSE.txt Authors \u00b6 The rio-tiler project was begun at Mapbox and has been transferred in January 2019. See AUTHORS.txt for a listing of individual contributors. Changes \u00b6 See CHANGES.txt .","title":"Home"},{"location":"#rio-tiler","text":"Rasterio plugin to read mercator tiles from Cloud Optimized GeoTIFF.","title":"Rio-tiler"},{"location":"#install","text":"You can install rio-tiler using pip $ pip install -U pip $ pip install rio-tiler --pre # version 2.0 is in development or install from source: $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -U pip $ pip install -e .","title":"Install"},{"location":"#usage","text":"The rio_tiler module can create mercator tiles from any raster source supported by Rasterio/GDAL (i.e. local files, http, s3, gcs etc.). Additional method are availables (see COGReader )","title":"Usage"},{"location":"#read-a-tile-from-a-file","text":"from rio_tiler.io import COGReader with COGReader ( \"http://oin-hotosm.s3.amazonaws.com/5a95f32c2553e6000ce5ad2e/0/10edab38-1bdd-4c06-b83d-6e10ac532b7d.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) print ( mask . shape ) > ( 256 , 256 )","title":"Read a tile from a file"},{"location":"#render-the-array-as-an-image-pngjpeg","text":"from rio_tiler.utils import render buffer = render ( tile , mask = mask ) # this returns a buffer (PNG by default) Rescale non-byte data and/or apply colormap from rio_tiler.colormap import cmap from rio_tiler.utils import linear_rescale # Rescale the tile array only where mask is valid and cast it to byte tile = numpy . where ( mask , linear_rescale ( tile , in_range = ( 0 , 1000 ), out_range = [ 0 , 255 ]), 0 ) . astype ( numpy . uint8 ) cm = cmap . get ( \"viridis\" ) buffer = render ( tile , mask = mask , colormap = cm ) Use creation options to match mapnik defaults. from rio_tiler.utils import render from rio_tiler.profiles import img_profiles options = img_profiles . get ( \"webp\" ) buffer = render ( tile , mask = mask , img_format = \"webp\" , ** options ) Write image to file with open ( \"my.png\" , \"wb\" ) as f : f . write ( buffer )","title":"Render the array as an image (PNG/JPEG)"},{"location":"#cogreader","text":"class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. info: dict General information about the COG (datatype, indexes, ...) stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\"","title":"COGReader"},{"location":"#properties","text":"dataset : Return the rasterio dataset colormap : Return the dataset's internal colormap minzoom : Return minimum Mercator Zoom maxzoom : Return maximum Mercator Zoom bounds : Return the dataset bounds in WGS84 center : Return the center of the dataset + minzoom spatial_info : Return the bounds, center and zoom infos","title":"Properties"},{"location":"#methods","text":"tile() : Read map tile from a raster with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" s ) as cog : tile , mask = cog . tile ( 1 , 2 , 3 , tilesize = 256 , expression = \"B1/B2\" ) part() : Read part of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 )) # Limit output size (default is set to 1024) with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = 2000 ) # Read high resolution with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), max_size = None ) # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . part (( 10 , 10 , 20 , 20 ), expression = \"B1/B2\" ) preview() : Read a preview of a raster with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview () # With indexes with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( indexes = 1 ) # With expression with COGReader ( \"myfile.tif\" ) as cog : data , mask = cog . preview ( expression = \"B1+2,B1*4\" ) point() : Read point value of a raster with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 )) # With indexes with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , indexes = 1 )) [ 1 ] # With expression with COGReader ( \"myfile.tif\" ) as cog : print ( cog . point ( - 100 , 25 , expression = \"B1+2,B1*4\" )) [ 3 , 4 ] info() : Return simple metadata about the dataset with COGReader ( \"myfile.tif\" ) as cog : print ( cog . info ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } } stats() : Return image statistics (Min/Max/Stdev) with COGReader ( \"myfile.tif\" ) as cog : print ( cog . stats ()) { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } metadata() : Return COG info + statistics with COGReader ( \"myfile.tif\" ) as cog : print ( cog . metadata ()) { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"center\" : [ - 101.98868496889182 , 23.548959503763047 , 3 ], \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_metadata\" : [[ 1 , {}]], \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"nodata_type\" : \"Nodata\" , \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], ... } \"statistics\" : { 1 : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } } }","title":"Methods"},{"location":"#global-options","text":"COGReader accept several options which will be forwarded to the rio_tiler.reader._read function (low level function accessing the data): - nodata : Overwrite the nodata value (or set if not present) - unscale : Apply internal rescaling factors - vrt_options : Pass WarpedVRT Option (see: gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions ) Note: Those options could already be passed on each method call. with COGReader ( \"my_cog.tif\" , nodata = 0 ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 ) # is equivalent to with COGReader ( \"my_cog.tif\" ) as cog : tile , mask = cog . tile ( 1 , 1 , 1 , nodata = 0 )","title":"Global Options"},{"location":"#stacreader","text":"In rio-tiler v2, we added a rio_tiler.io.STACReader to allow tile/metadata fetching of assets withing a STAC item. The STACReader objects has the same properties/methods as the COGReader. from typing import Dict from rio_tiler.io import STACReader with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : print ( stac . bounds ) print ( stac . assets ) > [ 23.293255090449595 , 31.505183020453355 , 24.296453548295318 , 32.51147809805106 ] > [ 'overview' , 'visual' , 'B01' , 'B02' , 'B03' , 'B04' , 'B05' , 'B06' , 'B07' , 'B08' , 'B8A' , 'B09' , 'B11' , 'B12' , 'AOT' , 'WVP' , 'SCL' ] # Name of assets to read assets = [ \"B01\" , \"B02\" ] with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , assets = assets ) print ( tile . shape ) > ( 2 , 256 , 256 ) # With expression with STACReader ( \"https://1tqdbvsut9.execute-api.us-west-2.amazonaws.com/v0/collections/sentinel-s2-l2a-cogs/items/S2A_34SGA_20200318_0_L2A\" , exclude_assets = { \"thumbnail\" } ) as stac : tile , mask = stac . tile ( 145 , 103 , 8 , tilesize = 256 , expression = \"B01/B02\" ) print ( tile . shape ) > ( 1 , 256 , 256 ) Note: STACReader is based on rio_tiler.io.base.MultiBaseReader class.","title":"STACReader"},{"location":"#working-with-multiple-assets","text":"","title":"Working with multiple assets"},{"location":"#mosaic","text":"Starting in rio-tiler 2.0, we've transfered the rio-tiler-mosaic plugin to be a rio-tiler submodule. from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] ( tile , mask ), assets_used = mosaic_reader ( assets , tiler , 1 , 1 , 1 ) Learn more about rio_tiler.mosaic in docs/mosaic.md . Notebook: WorkingWithMosaic","title":"Mosaic"},{"location":"#merge-assets","text":"rio_tiler.io.cogeo submodule has multi_* functions (tile, part, preview, point, metadata, info, stats) allowing to fetch and merge info/data from multiple dataset (think about multiple bands stored in separated files). from typing import Dict from rio_tiler.io.cogeo import multi_tile assets = [ \"b1.tif\" , \"b2.tif\" , \"b3.tif\" ] tile , mask = multi_tile ( assets , x , y , z , tilesize = 256 ) print ( tile . shape ) > ( 3 , 256 , 256 ) # Others metadata = multi_info ( assets ) stats = multi_stats ( assets , pmin = 2 , pmax = 98 , ... ) metadata = multi_metadata ( assets , pmin = 2 , pmax = 98 , ... ) values = multi_points ( assets , lon , lat , ... ) data , mask = multi_part ( assets , bbox , ... ) data , mask = multi_preview ( assets , ... ) You can also use rio_tiler.io.base.MultiBaseReader to build a custom asset reader: import attr from rio_tiler.io.base import MultiBaseReader from rio_tiler.io import COGReader , BaseReader # CustomReader is a subclass of MultiBaseReader. # To ease the creation of the class and because MultiBaseReader is built with `attr` # we also need to add the `@attr.s` wrapper on top of our custom class. @attr . s class CustomReader ( MultiBaseReader ): directory : str = attr . ib () # required arg reader : Type [ BaseReader ] = attr . ib ( default = COGReader ) # the default reader is COGReader def __enter__ ( self ): # List files in directory dirs = os . listdir ( self . directory ) # get list of tifs tiff = [ f for f in dirs if f . endswith ( \".tif\" )] # create list of assets names - REQUIRED self . assets = [ os . path . basename ( f ) . split ( \".\" )[ 0 ] for f in tiff ] # `self.bounds` needs to be set! - REQUIRED with self . reader ( tiff [ 0 ]) as cog : self . bounds = cog . bounds return self def _get_asset_url ( self , asset : str ) -> str : \"\"\"Validate asset names and return asset's url.\"\"\" if asset not in self . assets : raise InvalidAssetName ( f \" { asset } is not valid\" ) return os . path . join ( self . directory , f \" { asset } .tif\" ) # we have a directoty with \"b1.tif\", \"b2.tif\", \"b3.tif\" with CustomReader ( \"my_dir/\" ) as cr : print ( cr . assets ) tile , mask = cr . tile ( x , y , z , assets = \"b1\" ) > [ \"b1\" , \"b2\" , \"b3\" ] print ( tile . shape ) > ( 3 , 256 , 256 )","title":"Merge assets"},{"location":"#reading-asset-with-a-geojson-polygon","text":"Natively rio-tiler support mostly bbox reading. Using GDALWarpVRT Cutline option, it's possible to read a dataset for a given polygon. from rio_tiler.io import COGReader from rio_tiler.utils import create_cutline from rasterio.features import bounds as featureBounds feat = { \"type\" : \"Feature\" , \"properties\" : {}, \"geometry\" : { \"type\" : \"Polygon\" , \"coordinates\" : [ [ [ - 52.6025390625 , 73.86761239709705 ], [ - 52.6025390625 , 73.59679245247814 ], [ - 51.591796875 , 73.60299628304274 ], [ - 51.591796875 , 73.90420357134279 ], [ - 52.4267578125 , 74.0437225981325 ], [ - 52.6025390625 , 73.86761239709705 ] ] ] } } # Get BBOX of the polygon bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Read part of the data (bbox) and use the cutline to mask the data data , mask = cog . part ( bbox , vrt_options = { 'cutline' : cutline }) The previous example uses the .part method but any method that uses the rio_tiler.reader._read function will accept the cutline options. bbox = featureBounds ( feat ) # Use COGReader to open and read the dataset with COGReader ( \"my_tif.tif\" ) as cog : # Create WTT Cutline cutline = create_cutline ( cog . dataset , feat , geometry_crs = \"epsg:4326\" ) # Get a preview of the whole geotiff but use the cutline to mask the data data , mask = cog . preview ( vrt_options = { 'cutline' : cutline }) # Read a mercator tile and use the cutline to mask the data data , mask = cog . tile ( 1 , 1 , 1 , vrt_options = { 'cutline' : cutline }) # Get image statistics over a bbox and use the cutline as mask stats = cog . stats ( bounds = bbox , vrt_options = { 'cutline' : cutline })","title":"Reading asset with a GeoJSON Polygon"},{"location":"#partial-reading-on-cloud-hosted-dataset","text":"Rio-tiler perform partial reading on local or distant dataset, which is why it will perform best on Cloud Optimized GeoTIFF (COG). It's important to note that Sentinel-2 scenes hosted on AWS are not in Cloud Optimized format but in JPEG2000 . When performing partial reading of JPEG2000 dataset GDAL (rasterio backend library) will need to make a lot of GET requests and transfer a lot of data. Ref: Do you really want people using your data blog post.","title":"Partial reading on Cloud hosted dataset"},{"location":"#create-an-aws-lambda-package","text":"The easiest way to make sure the package will work on AWS is to use docker FROM lambci/lambda:build-python3.7 ENV LANG = en_US.UTF-8 LC_ALL = en_US.UTF-8 CFLAGS = \"--std=c99\" RUN pip3 install rio-tiler --no-binary numpy -t /tmp/python -U RUN cd /tmp/python && zip -r9q /tmp/package.zip * Ref: vincentsarago/simple-rio-lambda","title":"Create an AWS Lambda package"},{"location":"#mission-specific-tiler","text":"In rio-tiler v2 we choosed to remove the mission specific tilers (Sentinel2, Sentinel1, Landsat8 and CBERS). Those are now in a specific plugin: rio-tiler-pds .","title":"Mission Specific tiler"},{"location":"#plugins","text":"rio-tiler-mvt : Create Mapbox Vector Tile from numpy array (tile/mask) rio-tiler-crs : Create Map Tiles using other TileMatrixSets rio-viz : Visualize Cloud Optimized GeoTIFF in browser locally","title":"Plugins"},{"location":"#implementations","text":"CosmiQ/solaris cogeo-tiler titiler","title":"Implementations"},{"location":"#contribution-development","text":"Issues and pull requests are more than welcome. dev install $ git clone https://github.com/cogeotiff/rio-tiler.git $ cd rio-tiler $ pip install -e . [ dev ] Python3.7 only This repo is set to use pre-commit to run isort , flake8 , pydocstring , black (\"uncompromising Python code formatter\") and mypy when committing new code. $ pre-commit install","title":"Contribution &amp; Development"},{"location":"#license","text":"See LICENSE.txt","title":"License"},{"location":"#authors","text":"The rio-tiler project was begun at Mapbox and has been transferred in January 2019. See AUTHORS.txt for a listing of individual contributors.","title":"Authors"},{"location":"#changes","text":"See CHANGES.txt .","title":"Changes"},{"location":"colormap/","text":"Colormaps \u00b6 Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data. You can load a colormap with rio_tiler.colormap.get_colormap , and then pass it to rio_tiler.utils.render : from rio_tiler.colormap import cmap from rio_tiler.utils import render colormap = cmap . get ( 'cfastie' ) render ( tile , mask , colormap = colormap ) References \u00b6 Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html cfastie : publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap rplumbo : cogeotiff/rio-tiler!90 schwarzwald : soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html Update images for new colormaps \u00b6 To regenerate these images for new colormaps, update the list of colormaps at the top of scripts/colormap_thumb.py and then run python scripts/colormap_thumb.py","title":"Colormaps"},{"location":"colormap/#colormaps","text":"Rio-tiler includes many colormaps, some derived from Matplotlib and some custom ones that are commonly used with raster data. You can load a colormap with rio_tiler.colormap.get_colormap , and then pass it to rio_tiler.utils.render : from rio_tiler.colormap import cmap from rio_tiler.utils import render colormap = cmap . get ( 'cfastie' ) render ( tile , mask , colormap = colormap )","title":"Colormaps"},{"location":"colormap/#references","text":"Matplotlib colormaps: matplotlib.org/3.1.0/tutorials/colors/colormaps.html cfastie : publiclab.org/notes/cfastie/08-26-2014/new-ndvi-colormap rplumbo : cogeotiff/rio-tiler!90 schwarzwald : soliton.vm.bytemark.co.uk/pub/cpt-city/wkp/schwarzwald/tn/wiki-schwarzwald-cont.png.index.html","title":"References"},{"location":"colormap/#update-images-for-new-colormaps","text":"To regenerate these images for new colormaps, update the list of colormaps at the top of scripts/colormap_thumb.py and then run python scripts/colormap_thumb.py","title":"Update images for new colormaps"},{"location":"dynamic_tiler/","text":"Dynamic Tiling \u00b6 rio-tiler aims to be a lightweight plugin for rasterio whose sole goal is to read a Mercator Tile from a raster dataset. Given that rio-tiler allows for simple, efficient reading of tiles, you can then leverage rio-tiler to create a dynamic tile server to display raster tiles on a web map. There are couple tile servers built on top of rio-tiler: titiler cogeo-tiler cogeo-mosaic-tiler rio-viz Example Application \u00b6 To build a simple dynamic tiling application, we can use FastAPI . Note that titiler uses FastAPI internally, so you might consider using titiler instead of making your own API. Requirements \u00b6 rio-tiler ~= 2.0b fastapi uvicorn Install with pip install fastapi uvicorn 'rio-tiler~=2.0b' app.py \u00b6 \"\"\"rio-tiler tile server.\"\"\" import os from enum import Enum from typing import Any , Dict , List , Optional from urllib.parse import urlencode import uvicorn from fastapi import FastAPI , Path , Query from rasterio.crs import CRS from starlette.background import BackgroundTask from starlette.middleware.cors import CORSMiddleware from starlette.middleware.gzip import GZipMiddleware from starlette.requests import Request from starlette.responses import Response from rio_tiler.profiles import img_profiles from rio_tiler.utils import render from rio_tiler.io import COGReader # From developmentseed/titiler drivers = dict ( jpg = \"JPEG\" , png = \"PNG\" ) mimetype = dict ( png = \"image/png\" , jpg = \"image/jpg\" ,) class ImageType ( str , Enum ): \"\"\"Image Type Enums.\"\"\" png = \"png\" jpg = \"jpg\" class TileResponse ( Response ): \"\"\"Tiler's response.\"\"\" def __init__ ( self , content : bytes , media_type : str , status_code : int = 200 , headers : dict = {}, background : BackgroundTask = None , ttl : int = 3600 , ) -> None : \"\"\"Init tiler response.\"\"\" headers . update ({ \"Content-Type\" : media_type }) if ttl : headers . update ({ \"Cache-Control\" : \"max-age=3600\" }) self . body = self . render ( content ) self . status_code = 200 self . media_type = media_type self . background = background self . init_headers ( headers ) app = FastAPI ( title = \"rio-tiler\" , description = \"A lightweight Cloud Optimized GeoTIFF tile server\" , ) app . add_middleware ( CORSMiddleware , allow_origins = [ \"*\" ], allow_credentials = True , allow_methods = [ \"GET\" ], allow_headers = [ \"*\" ], ) app . add_middleware ( GZipMiddleware , minimum_size = 0 ) responses = { 200 : { \"content\" : { \"image/png\" : {}, \"image/jpg\" : {}}, \"description\" : \"Return an image.\" , } } tile_routes_params : Dict [ str , Any ] = dict ( responses = responses , tags = [ \"tiles\" ], response_class = TileResponse ) @app . get ( \"/ {z} / {x} / {y} \" , ** tile_routes_params ) def tile ( z : int , x : int , y : int , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), ): \"\"\"Handle tiles requests.\"\"\" with COGReader ( url ) as cog : tile , mask = cog . tile ( x , y , z , tilesize = 256 ) format = ImageType . jpg if mask . all () else ImageType . png driver = drivers [ format . value ] options = img_profiles . get ( driver . lower (), {}) img = render ( tile , mask , img_format = driver , ** options ) return TileResponse ( img , media_type = mimetype [ format . value ]) @app . get ( \"/tilejson.json\" , responses = { 200 : { \"description\" : \"Return a tilejson\" }}) def tilejson ( request : Request , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), minzoom : Optional [ int ] = Query ( None , description = \"Overwrite default minzoom.\" ), maxzoom : Optional [ int ] = Query ( None , description = \"Overwrite default maxzoom.\" ), ): \"\"\"Return TileJSON document for a COG.\"\"\" tile_url = request . url_for ( \"tile\" , { \"z\" : \" {z} \" , \"x\" : \" {x} \" , \"y\" : \" {y} \" }) . replace ( \" \\\\ \" , \"\" ) kwargs = dict ( request . query_params ) kwargs . pop ( \"tile_format\" , None ) kwargs . pop ( \"tile_scale\" , None ) kwargs . pop ( \"minzoom\" , None ) kwargs . pop ( \"maxzoom\" , None ) qs = urlencode ( list ( kwargs . items ())) tile_url = f \" { tile_url } ? { qs } \" with COGReader ( url ) as cog : center = list ( cog . center ) if minzoom : center [ - 1 ] = minzoom tjson = { \"bounds\" : cog . bounds , \"center\" : tuple ( center ), \"minzoom\" : minzoom or cog . minzoom , \"maxzoom\" : maxzoom or cog . maxzoom , \"name\" : os . path . basename ( url ), \"tiles\" : [ tile_url ], } return tjson Launch Example \u00b6 Use uvicorn to launch the application. Note that app:app tells uvicorn to call the app function within app.py , so you must be in the same directory as app.py . uvicorn app:app --reload","title":"Dynamic Tiling"},{"location":"dynamic_tiler/#dynamic-tiling","text":"rio-tiler aims to be a lightweight plugin for rasterio whose sole goal is to read a Mercator Tile from a raster dataset. Given that rio-tiler allows for simple, efficient reading of tiles, you can then leverage rio-tiler to create a dynamic tile server to display raster tiles on a web map. There are couple tile servers built on top of rio-tiler: titiler cogeo-tiler cogeo-mosaic-tiler rio-viz","title":"Dynamic Tiling"},{"location":"dynamic_tiler/#example-application","text":"To build a simple dynamic tiling application, we can use FastAPI . Note that titiler uses FastAPI internally, so you might consider using titiler instead of making your own API.","title":"Example Application"},{"location":"dynamic_tiler/#requirements","text":"rio-tiler ~= 2.0b fastapi uvicorn Install with pip install fastapi uvicorn 'rio-tiler~=2.0b'","title":"Requirements"},{"location":"dynamic_tiler/#apppy","text":"\"\"\"rio-tiler tile server.\"\"\" import os from enum import Enum from typing import Any , Dict , List , Optional from urllib.parse import urlencode import uvicorn from fastapi import FastAPI , Path , Query from rasterio.crs import CRS from starlette.background import BackgroundTask from starlette.middleware.cors import CORSMiddleware from starlette.middleware.gzip import GZipMiddleware from starlette.requests import Request from starlette.responses import Response from rio_tiler.profiles import img_profiles from rio_tiler.utils import render from rio_tiler.io import COGReader # From developmentseed/titiler drivers = dict ( jpg = \"JPEG\" , png = \"PNG\" ) mimetype = dict ( png = \"image/png\" , jpg = \"image/jpg\" ,) class ImageType ( str , Enum ): \"\"\"Image Type Enums.\"\"\" png = \"png\" jpg = \"jpg\" class TileResponse ( Response ): \"\"\"Tiler's response.\"\"\" def __init__ ( self , content : bytes , media_type : str , status_code : int = 200 , headers : dict = {}, background : BackgroundTask = None , ttl : int = 3600 , ) -> None : \"\"\"Init tiler response.\"\"\" headers . update ({ \"Content-Type\" : media_type }) if ttl : headers . update ({ \"Cache-Control\" : \"max-age=3600\" }) self . body = self . render ( content ) self . status_code = 200 self . media_type = media_type self . background = background self . init_headers ( headers ) app = FastAPI ( title = \"rio-tiler\" , description = \"A lightweight Cloud Optimized GeoTIFF tile server\" , ) app . add_middleware ( CORSMiddleware , allow_origins = [ \"*\" ], allow_credentials = True , allow_methods = [ \"GET\" ], allow_headers = [ \"*\" ], ) app . add_middleware ( GZipMiddleware , minimum_size = 0 ) responses = { 200 : { \"content\" : { \"image/png\" : {}, \"image/jpg\" : {}}, \"description\" : \"Return an image.\" , } } tile_routes_params : Dict [ str , Any ] = dict ( responses = responses , tags = [ \"tiles\" ], response_class = TileResponse ) @app . get ( \"/ {z} / {x} / {y} \" , ** tile_routes_params ) def tile ( z : int , x : int , y : int , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), ): \"\"\"Handle tiles requests.\"\"\" with COGReader ( url ) as cog : tile , mask = cog . tile ( x , y , z , tilesize = 256 ) format = ImageType . jpg if mask . all () else ImageType . png driver = drivers [ format . value ] options = img_profiles . get ( driver . lower (), {}) img = render ( tile , mask , img_format = driver , ** options ) return TileResponse ( img , media_type = mimetype [ format . value ]) @app . get ( \"/tilejson.json\" , responses = { 200 : { \"description\" : \"Return a tilejson\" }}) def tilejson ( request : Request , url : str = Query ( ... , description = \"Cloud Optimized GeoTIFF URL.\" ), minzoom : Optional [ int ] = Query ( None , description = \"Overwrite default minzoom.\" ), maxzoom : Optional [ int ] = Query ( None , description = \"Overwrite default maxzoom.\" ), ): \"\"\"Return TileJSON document for a COG.\"\"\" tile_url = request . url_for ( \"tile\" , { \"z\" : \" {z} \" , \"x\" : \" {x} \" , \"y\" : \" {y} \" }) . replace ( \" \\\\ \" , \"\" ) kwargs = dict ( request . query_params ) kwargs . pop ( \"tile_format\" , None ) kwargs . pop ( \"tile_scale\" , None ) kwargs . pop ( \"minzoom\" , None ) kwargs . pop ( \"maxzoom\" , None ) qs = urlencode ( list ( kwargs . items ())) tile_url = f \" { tile_url } ? { qs } \" with COGReader ( url ) as cog : center = list ( cog . center ) if minzoom : center [ - 1 ] = minzoom tjson = { \"bounds\" : cog . bounds , \"center\" : tuple ( center ), \"minzoom\" : minzoom or cog . minzoom , \"maxzoom\" : maxzoom or cog . maxzoom , \"name\" : os . path . basename ( url ), \"tiles\" : [ tile_url ], } return tjson","title":"app.py"},{"location":"dynamic_tiler/#launch-example","text":"Use uvicorn to launch the application. Note that app:app tells uvicorn to call the app function within app.py , so you must be in the same directory as app.py . uvicorn app:app --reload","title":"Launch Example"},{"location":"mosaic/","text":"Using rio-tiler with Mosaics \u00b6 The rio-tiler-mosaic library has been moved into rio-tiler . The goal of the rio_tiler.mosaic module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest. Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the rio-tiler.mosaic module provides pixel selection methods which define how to handle these cases for each pixel: First : select value from the first non-missing asset Highest : loop though all the assets and return the highest value Lowest : loop though all the assets and return the lowest value Mean : compute the mean value of the whole stack Median : compute the median value of the whole stack API \u00b6 rio_tiler.mosaic.mosaic_reader(assets, tiler, *args* pixel_selection=None, chunk_size=None, Threads=10, **kwargs) Inputs: assets : list, tuple of rio-tiler compatible assets (url or sceneid) tiler: Callable that returns a tuple of numpy.array (e.g tile, mask = rio_tiler.reader.tile(x, y, z, **kwargs) ) *args: tiler specific arguments. pixel_selection : optional pixel selection algorithm (default: \"first\"). chunk_size: optional, control the number of asset to process per loop. **kwargs: tiler specific keyword arguments. Returns: - (tile, mask), assets_used : tuple of ndarray Return (tile and mask) data and the list of used assets. Examples \u00b6 from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] tile = ( 1000 , 1000 , 9 ) x , y , z = tile # Use Default First value method mosaic_reader ( assets , tiler , x , y , z ) # Use Highest value: defaults.HighestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . HighestMethod () ) # Use Lowest value: defaults.LowestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . LowestMethod () ) The MosaicMethod interface \u00b6 the rio_tiler.mosaic.methods.base.MosaicMethodBase class defines an abstract interface for all pixel selection methods allowed by rio_tiler.mosaic.mosaic_reader . its methods and properties are: is_done : property, returns a boolean indicating if the process is done filling the tile data : property, returns the output tile and mask numpy arrays feed(tile: numpy.ma.ndarray) : method, update the tile The MosaicMethodBase class is not intended to be used directly but as an abstract base class, a template for concrete implementations. Writing your own Pixel Selection method \u00b6 The rules for writing your own pixel selection algorithm class are as follows: Must inherit from MosaicMethodBase Must provide concrete implementations of all the above methods. See rio_tiler.mosaic.methods.defaults classes for examples. Smart Multi-Threading \u00b6 When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, rio_tiler.mosaic.mosaic_reader is fetching the tiles in parallel (threads) but to limit the number of files we also embeded the fetching in a loop (creating 2 level of processing): assets = [ \"1.tif\" , \"2.tif\" , \"3.tif\" , \"4.tif\" , \"5.tif\" , \"6.tif\" ] # 1st level loop - Creates chuncks of assets for chunks in _chunks ( assets , chunk_size ): # 2nd level loop - Uses threads for process each `chunck` with futures . ThreadPoolExecutor ( max_workers = max_threads ) as executor : future_tasks = [( executor . submit ( _tiler , asset ), asset ) for asset in chunks ] By default the chunck_size is equal to the number or threads (or the number of assets if no threads=0) More on threading \u00b6 The number of threads used can be set in the function call with the threads= options. By default it will be equal to multiprocessing.cpu_count() * 5 or to the MAX_THREADS environment variable. In some case, threading can slow down your application. You can set threads to 0 or 1 to run the tiler in a loop without using a ThreadPool. Benchmark: --------------------------------- benchmark '1images': 6 tests --------------------------------- Name (time in ms) Min Max Mean Median ------------------------------------------------------------------------------------------------ 1images-0threads 64.3108 (1.0) 66.9192 (1.0) 65.0202 (1.0) 64.9370 (1.0) 1images-4threads 69.0893 (1.07) 70.9919 (1.06) 69.6718 (1.07) 69.5102 (1.07) 1images-1threads 69.4884 (1.08) 71.8967 (1.07) 70.0853 (1.08) 69.9804 (1.08) 1images-5threads 69.5552 (1.08) 75.5498 (1.13) 71.7882 (1.10) 70.9849 (1.09) 1images-3threads 69.7684 (1.08) 74.4098 (1.11) 70.6282 (1.09) 70.2353 (1.08) 1images-2threads 69.9258 (1.09) 73.8798 (1.10) 70.8861 (1.09) 70.3682 (1.08) ------------------------------------------------------------------------------------------------ ----------------------------------- benchmark '5images': 6 tests ----------------------------------- Name (time in ms) Min Max Mean Median ---------------------------------------------------------------------------------------------------- 5images-5threads 104.1609 (1.0) 123.4442 (1.0) 110.4130 (1.0) 110.0683 (1.0) 5images-4threads 160.0952 (1.54) 170.7994 (1.38) 163.6062 (1.48) 161.8923 (1.47) 5images-3threads 161.2354 (1.55) 172.0363 (1.39) 165.1222 (1.50) 164.6513 (1.50) 5images-2threads 214.2413 (2.06) 220.7737 (1.79) 217.7740 (1.97) 217.9166 (1.98) 5images-0threads 228.2062 (2.19) 242.9397 (1.97) 231.9848 (2.10) 229.2843 (2.08) 5images-1threads 248.6630 (2.39) 251.8809 (2.04) 250.5195 (2.27) 251.2667 (2.28) ---------------------------------------------------------------------------------------------------- ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838 As mentioned in #207, using ThreadPool with 1 thread is always slower than not using thread.","title":"Mosaic"},{"location":"mosaic/#using-rio-tiler-with-mosaics","text":"The rio-tiler-mosaic library has been moved into rio-tiler . The goal of the rio_tiler.mosaic module is to create a mercator tile from multiple observations. This is useful when a source image doesn't fill the entire mercator tile of interest. Often when creating a mercator tile from multiple assets, there will be portions of overlap where a pixel could be chosen from multiple datasets. To handle this, the rio-tiler.mosaic module provides pixel selection methods which define how to handle these cases for each pixel: First : select value from the first non-missing asset Highest : loop though all the assets and return the highest value Lowest : loop though all the assets and return the lowest value Mean : compute the mean value of the whole stack Median : compute the median value of the whole stack","title":"Using rio-tiler with Mosaics"},{"location":"mosaic/#api","text":"rio_tiler.mosaic.mosaic_reader(assets, tiler, *args* pixel_selection=None, chunk_size=None, Threads=10, **kwargs) Inputs: assets : list, tuple of rio-tiler compatible assets (url or sceneid) tiler: Callable that returns a tuple of numpy.array (e.g tile, mask = rio_tiler.reader.tile(x, y, z, **kwargs) ) *args: tiler specific arguments. pixel_selection : optional pixel selection algorithm (default: \"first\"). chunk_size: optional, control the number of asset to process per loop. **kwargs: tiler specific keyword arguments. Returns: - (tile, mask), assets_used : tuple of ndarray Return (tile and mask) data and the list of used assets.","title":"API"},{"location":"mosaic/#examples","text":"from rio_tiler.io import COGReader from rio_tiler.mosaic import mosaic_reader from rio_tiler.mosaic.methods import defaults def tiler ( src_path : str , * args , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ]: with COGReader ( src_path ) as cog : return cog . tile ( * args , ** kwargs ) assets = [ \"mytif1.tif\" , \"mytif2.tif\" , \"mytif3.tif\" ] tile = ( 1000 , 1000 , 9 ) x , y , z = tile # Use Default First value method mosaic_reader ( assets , tiler , x , y , z ) # Use Highest value: defaults.HighestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . HighestMethod () ) # Use Lowest value: defaults.LowestMethod() mosaic_reader ( assets , tiler , x , y , z , pixel_selection = defaults . LowestMethod () )","title":"Examples"},{"location":"mosaic/#the-mosaicmethod-interface","text":"the rio_tiler.mosaic.methods.base.MosaicMethodBase class defines an abstract interface for all pixel selection methods allowed by rio_tiler.mosaic.mosaic_reader . its methods and properties are: is_done : property, returns a boolean indicating if the process is done filling the tile data : property, returns the output tile and mask numpy arrays feed(tile: numpy.ma.ndarray) : method, update the tile The MosaicMethodBase class is not intended to be used directly but as an abstract base class, a template for concrete implementations.","title":"The MosaicMethod interface"},{"location":"mosaic/#writing-your-own-pixel-selection-method","text":"The rules for writing your own pixel selection algorithm class are as follows: Must inherit from MosaicMethodBase Must provide concrete implementations of all the above methods. See rio_tiler.mosaic.methods.defaults classes for examples.","title":"Writing your own Pixel Selection method"},{"location":"mosaic/#smart-multi-threading","text":"When dealing with an important number of image, you might not want to process the whole stack, especially if the pixel selection method stops when the tile is filled. To allow better optimization, rio_tiler.mosaic.mosaic_reader is fetching the tiles in parallel (threads) but to limit the number of files we also embeded the fetching in a loop (creating 2 level of processing): assets = [ \"1.tif\" , \"2.tif\" , \"3.tif\" , \"4.tif\" , \"5.tif\" , \"6.tif\" ] # 1st level loop - Creates chuncks of assets for chunks in _chunks ( assets , chunk_size ): # 2nd level loop - Uses threads for process each `chunck` with futures . ThreadPoolExecutor ( max_workers = max_threads ) as executor : future_tasks = [( executor . submit ( _tiler , asset ), asset ) for asset in chunks ] By default the chunck_size is equal to the number or threads (or the number of assets if no threads=0)","title":"Smart Multi-Threading"},{"location":"mosaic/#more-on-threading","text":"The number of threads used can be set in the function call with the threads= options. By default it will be equal to multiprocessing.cpu_count() * 5 or to the MAX_THREADS environment variable. In some case, threading can slow down your application. You can set threads to 0 or 1 to run the tiler in a loop without using a ThreadPool. Benchmark: --------------------------------- benchmark '1images': 6 tests --------------------------------- Name (time in ms) Min Max Mean Median ------------------------------------------------------------------------------------------------ 1images-0threads 64.3108 (1.0) 66.9192 (1.0) 65.0202 (1.0) 64.9370 (1.0) 1images-4threads 69.0893 (1.07) 70.9919 (1.06) 69.6718 (1.07) 69.5102 (1.07) 1images-1threads 69.4884 (1.08) 71.8967 (1.07) 70.0853 (1.08) 69.9804 (1.08) 1images-5threads 69.5552 (1.08) 75.5498 (1.13) 71.7882 (1.10) 70.9849 (1.09) 1images-3threads 69.7684 (1.08) 74.4098 (1.11) 70.6282 (1.09) 70.2353 (1.08) 1images-2threads 69.9258 (1.09) 73.8798 (1.10) 70.8861 (1.09) 70.3682 (1.08) ------------------------------------------------------------------------------------------------ ----------------------------------- benchmark '5images': 6 tests ----------------------------------- Name (time in ms) Min Max Mean Median ---------------------------------------------------------------------------------------------------- 5images-5threads 104.1609 (1.0) 123.4442 (1.0) 110.4130 (1.0) 110.0683 (1.0) 5images-4threads 160.0952 (1.54) 170.7994 (1.38) 163.6062 (1.48) 161.8923 (1.47) 5images-3threads 161.2354 (1.55) 172.0363 (1.39) 165.1222 (1.50) 164.6513 (1.50) 5images-2threads 214.2413 (2.06) 220.7737 (1.79) 217.7740 (1.97) 217.9166 (1.98) 5images-0threads 228.2062 (2.19) 242.9397 (1.97) 231.9848 (2.10) 229.2843 (2.08) 5images-1threads 248.6630 (2.39) 251.8809 (2.04) 250.5195 (2.27) 251.2667 (2.28) ---------------------------------------------------------------------------------------------------- ref: github.com/cogeotiff/rio-tiler/issues/207#issuecomment-665958838 As mentioned in #207, using ThreadPool with 1 thread is always slower than not using thread.","title":"More on threading"},{"location":"v2_migration/","text":"rio-tiler 1.0 to 2.0 migration \u00b6 rio-tiler version 2.0 introduced many breaking changes . This document aims to help with migrating your code to use rio-tiler 2.0. Python 3 only \u00b6 First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead . For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.5 or later is required. If you need help moving from Python 2 to 3 check out the official transition documentation . Type hints \u00b6 As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools. This does not require any changes to your code as long as you're using Python 3.6+. For more information see: fastapi.tiangolo.com/python-types/ kishstats.com/python/2019/01/07/python-type-hinting.html mypy.readthedocs.io/en/stable/cheat_sheet_py3.html Typing example: def get_vrt_transform ( src_dst : Union [ DatasetReader , DatasetWriter , WarpedVRT ], bounds : Tuple [ float , float , float , float ], dst_crs : CRS = constants . WEB_MERCATOR_CRS , ) -> Tuple [ Affine , int , int ]: Rasterio >= 1.1.3 \u00b6 Rasterio 1.1.3 or newer is required. Recent changes in rasterio makes masking more reliable. New rio_tiler.io submodules \u00b6 We created revised submodules for working with COGs and STAC: rio_tiler.io.cogeo is a modified version of the previous rio_tiler.main.tile . rio_tiler.io.stac is a new module to work with SpatioTemporal Asset Catalogs (STAC) . We now support reading files through a ContextManager to enable accessing the source rasterio dataset. # v1 from rio_tiler.main import tile as cogTiler tile , mask = cogTiler ( 'my_tif.tif' , 691559 , 956905 , 21 , tilesize = 256 ) # v2 from rio_tiler.io import COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( cog . dataset ) # rasterio dataset (returned by rasterio.open()) print ( cog . dataset . meta ) # rasterio metadata print ( cog . bounds ) # WGS84 bounds print ( cog . colormap ) # internal colormap Expression support is now directly available in the COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , expression = \"b1/b2\" ) COGReader description \u00b6 class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\" Internal API: rio_tiler.reader \u00b6 Internal tile/data reading functions have been refactored and moved to a new rio_tiler.reader submodule. tile \u00b6 In rio_tiler==1 most of the magic was happening in rio_tiler.utils._tile_read . In rio_tiler==2 this function is now split in two, rio_tiler.reader.part and rio_tiler_reader._read , to reduce code reutilisation and to make the code more robust. The part function now takes height and width instead of a unique tilesize to specify the output array size. To ease the transition we added a rio_tiler.reader.tile function. Note: The new rio_tiler.reader.part function enables to perform non-squared data cropping by passing output width and height (instead of just tilesize). # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : # get tile bounds and read raster mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) # Will check if tile is valid # Or with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . reader . part ( src_dst , tile_bounds , 256 , 256 ) Options changes - tile_edge_padding -> padding , and set to 0 by default - minimum_tile_cover -> minimum_overlap - unscale ( New ): add ability to apply scale and offset to the data (Default: False) # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , tile_edge_padding = 4 , minimum_tile_cover = 0.3 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 , padding = 4 , minimum_overlap = 0.3 ) Alpha band \u00b6 Since the first version, rio-tiler returns a tuple of (data, mask) in most of the reading function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126 , where a user gets a 4 bands data array + a mask (instead of 3 bands + mask). In rio-tiler=2. , when no indexes options are passed, we remove the alpha channel from the output data array. # v1 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , indexes = ( 1 , 2 , 3 )) # v2 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : # because rio-tiler will remove the alpha band we don't need to use the indexes option t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) metadata \u00b6 rio_tiler.utils._raster_get_stats has been replaced by rio_tiler.reader.metadata which uses the new reader.part and reader.preview functions. Meaning that now you can get metadata for a specific area by passing a bbox. To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use only the max_size options, meaning the overview_level options have been removed (at least for version 2.0.0). # v1 import rio_tiler with rasterio . open ( \"my_tif.tif\" ) as src_dst : meta = rio_tiler . utils . _raster_get_stats ( src_dst ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) Options changes - removed histogram_bins and histogram_range which should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - removed overview_level - added bounds Output The output has also been updated. The new metadata output doesn't return min/max zoom and bounds is return in WGS84 by default. # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . utils . _raster_get_stats ( src_dst ) > { \"bounds\" : { \"value\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"crs\" : \"EPSG:4326\" }, \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_descriptions\" : [ [ 1 , \"band1\" ] ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 17 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.418616203143802 , \"histogram\" : [ [ ... ], [ ... ] ] } } } # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) > { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } }, \"nodata_type\" : \"Nodata\" , \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], \"2\" : [ 148 , 56 , 112 , 255 ], ... } } colormaps \u00b6 In addition to a new colormap specific submodule ( rio_tiler.colormap ), in rio-tiler==2 , colormaps are now RGBA values. We also removed PIL colormap compatibility. # v1 cmap = rio_tiler . utils . get_colormap ( \"viridis\" , format = \"gdal\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 ] # v2 cmap = rio_tiler . colormap . get_colormap ( \"viridis\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 , 255 ] render \u00b6 In rio-tiler==1. * to create an image blob from an array we used the rio_tiler.utils.array_to_image function. We have renamed and slightly refactored the function but it works the same. # v1 img = rio_tiler . utils . array_to_image ( tile , mask , img_format = \"PNG\" ) # v2 img = rio_tiler . utils . render ( tile , mask , img_format = \"PNG\" ) Mission specific changes \u00b6 Mission-specific tilers have been moved to the rio-tiler-pds package. Each rio_tiler.io.{mission} scene id parser (e.g cbers_parser) has been refactored and now return AWS S3 path information. rio_tiler . io . landsat8 . landsat_parser ( \"LC08_L1TP_016037_20170813_20170814_01_RT\" )) { \"sensor\" : \"C\" , \"satellite\" : \"08\" , \"processingCorrectionLevel\" : \"L1TP\" , \"path\" : \"016\" , \"row\" : \"037\" , \"acquisitionYear\" : \"2017\" , \"acquisitionMonth\" : \"08\" , \"acquisitionDay\" : \"13\" , \"processingYear\" : \"2017\" , \"processingMonth\" : \"08\" , \"processingDay\" : \"14\" , \"collectionNumber\" : \"01\" , \"collectionCategory\" : \"RT\" , \"scene\" : \"LC08_L1TP_016037_20170813_20170814_01_RT\" , \"date\" : \"2017-08-13\" , --> \"scheme\" : \"s3\" , --> \"bucket\" : \"landsat-pds\" , --> \"prefix\" : \"c1/L8/016/037/LC08_L1TP_016037_20170813_20170814_01_RT\" }","title":"v2 Migration"},{"location":"v2_migration/#rio-tiler-10-to-20-migration","text":"rio-tiler version 2.0 introduced many breaking changes . This document aims to help with migrating your code to use rio-tiler 2.0.","title":"rio-tiler 1.0 to 2.0 migration"},{"location":"v2_migration/#python-3-only","text":"First and foremost is the drop of Python 2 support. We are in 2020 and Python 2 is officially dead . For ease of maintenance we decided to remove Python 2 support and to continue with only Python 3. Python 3.5 or later is required. If you need help moving from Python 2 to 3 check out the official transition documentation .","title":"Python 3 only"},{"location":"v2_migration/#type-hints","text":"As part of switching to Python 3, we also embraced modern code style with the adoption of type hints. Python 3.6+ has new syntax support for optional \"type hinting\" -- declaring the type of a variable -- which enables an improved development experience in editors and tools. This does not require any changes to your code as long as you're using Python 3.6+. For more information see: fastapi.tiangolo.com/python-types/ kishstats.com/python/2019/01/07/python-type-hinting.html mypy.readthedocs.io/en/stable/cheat_sheet_py3.html Typing example: def get_vrt_transform ( src_dst : Union [ DatasetReader , DatasetWriter , WarpedVRT ], bounds : Tuple [ float , float , float , float ], dst_crs : CRS = constants . WEB_MERCATOR_CRS , ) -> Tuple [ Affine , int , int ]:","title":"Type hints"},{"location":"v2_migration/#rasterio-113","text":"Rasterio 1.1.3 or newer is required. Recent changes in rasterio makes masking more reliable.","title":"Rasterio &gt;= 1.1.3"},{"location":"v2_migration/#new-rio_tilerio-submodules","text":"We created revised submodules for working with COGs and STAC: rio_tiler.io.cogeo is a modified version of the previous rio_tiler.main.tile . rio_tiler.io.stac is a new module to work with SpatioTemporal Asset Catalogs (STAC) . We now support reading files through a ContextManager to enable accessing the source rasterio dataset. # v1 from rio_tiler.main import tile as cogTiler tile , mask = cogTiler ( 'my_tif.tif' , 691559 , 956905 , 21 , tilesize = 256 ) # v2 from rio_tiler.io import COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , tilesize = 256 ) print ( cog . dataset ) # rasterio dataset (returned by rasterio.open()) print ( cog . dataset . meta ) # rasterio metadata print ( cog . bounds ) # WGS84 bounds print ( cog . colormap ) # internal colormap Expression support is now directly available in the COGReader with COGReader ( \"my_tif.tif\" ) as cog : tile , mask = cog . tile ( 691559 , 956905 , 21 , expression = \"b1/b2\" )","title":"New rio_tiler.io submodules"},{"location":"v2_migration/#cogreader-description","text":"class COGReader : \"\"\" Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics \"\"\"","title":"COGReader description"},{"location":"v2_migration/#internal-api-rio_tilerreader","text":"Internal tile/data reading functions have been refactored and moved to a new rio_tiler.reader submodule.","title":"Internal API: rio_tiler.reader"},{"location":"v2_migration/#tile","text":"In rio_tiler==1 most of the magic was happening in rio_tiler.utils._tile_read . In rio_tiler==2 this function is now split in two, rio_tiler.reader.part and rio_tiler_reader._read , to reduce code reutilisation and to make the code more robust. The part function now takes height and width instead of a unique tilesize to specify the output array size. To ease the transition we added a rio_tiler.reader.tile function. Note: The new rio_tiler.reader.part function enables to perform non-squared data cropping by passing output width and height (instead of just tilesize). # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : # get tile bounds and read raster mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 ) # Will check if tile is valid # Or with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . reader . part ( src_dst , tile_bounds , 256 , 256 ) Options changes - tile_edge_padding -> padding , and set to 0 by default - minimum_tile_cover -> minimum_overlap - unscale ( New ): add ability to apply scale and offset to the data (Default: False) # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : mercator_tile = mercantile . Tile ( x = tile_x , y = tile_y , z = tile_z ) tile_bounds = mercantile . xy_bounds ( mercator_tile ) t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , tile_edge_padding = 4 , minimum_tile_cover = 0.3 ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 , padding = 4 , minimum_overlap = 0.3 )","title":"tile"},{"location":"v2_migration/#alpha-band","text":"Since the first version, rio-tiler returns a tuple of (data, mask) in most of the reading function. This design was made early and without thinking about datasets with an alpha channel, which resulted in issues like #126 , where a user gets a 4 bands data array + a mask (instead of 3 bands + mask). In rio-tiler=2. , when no indexes options are passed, we remove the alpha channel from the output data array. # v1 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : t , m = rio_tiler . utils . _tile_read ( src , tile_bounds , 256 , indexes = ( 1 , 2 , 3 )) # v2 with rasterio . open ( \"my_tif_alpha.tif\" ) as src_dst : # because rio-tiler will remove the alpha band we don't need to use the indexes option t , m = rio_tiler . reader . tile ( src_dst , tile_x , tile_y , tile_z , 256 )","title":"Alpha band"},{"location":"v2_migration/#metadata","text":"rio_tiler.utils._raster_get_stats has been replaced by rio_tiler.reader.metadata which uses the new reader.part and reader.preview functions. Meaning that now you can get metadata for a specific area by passing a bbox. To limit the data transfer (with the idea of getting the metadata from the COG overviews) we use only the max_size options, meaning the overview_level options have been removed (at least for version 2.0.0). # v1 import rio_tiler with rasterio . open ( \"my_tif.tif\" ) as src_dst : meta = rio_tiler . utils . _raster_get_stats ( src_dst ) # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) Options changes - removed histogram_bins and histogram_range which should now be passed in hist_options (e.g: hist_options={bins=10, range=(0, 10)}) - removed overview_level - added bounds Output The output has also been updated. The new metadata output doesn't return min/max zoom and bounds is return in WGS84 by default. # v1 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . utils . _raster_get_stats ( src_dst ) > { \"bounds\" : { \"value\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"crs\" : \"EPSG:4326\" }, \"minzoom\" : 3 , \"maxzoom\" : 12 , \"band_descriptions\" : [ [ 1 , \"band1\" ] ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 17 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.418616203143802 , \"histogram\" : [ [ ... ], [ ... ] ] } } } # v2 with rasterio . open ( \"my_tif.tif\" ) as src_dst : rio_tiler . reader . metadata ( src_dst ) > { \"bounds\" : [ - 119.05915661478785 , 13.102845359730287 , - 84.91821332299578 , 33.995073647795806 ], \"statistics\" : { \"1\" : { \"pc\" : [ 1 , 16 ], \"min\" : 1 , \"max\" : 18 , \"std\" : 4.069636227214257 , \"histogram\" : [ [ ... ], [ ... ] ] } }, \"nodata_type\" : \"Nodata\" , \"band_descriptions\" : [[ 1 , \"band1\" ]], \"dtype\" : \"int8\" , \"colorinterp\" : [ \"palette\" ], \"colormap\" : { \"0\" : [ 0 , 0 , 0 , 0 ], \"1\" : [ 0 , 61 , 0 , 255 ], \"2\" : [ 148 , 56 , 112 , 255 ], ... } }","title":"metadata"},{"location":"v2_migration/#colormaps","text":"In addition to a new colormap specific submodule ( rio_tiler.colormap ), in rio-tiler==2 , colormaps are now RGBA values. We also removed PIL colormap compatibility. # v1 cmap = rio_tiler . utils . get_colormap ( \"viridis\" , format = \"gdal\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 ] # v2 cmap = rio_tiler . colormap . get_colormap ( \"viridis\" ) print ( cmap [ 0 ]) > [ 68 , 1 , 84 , 255 ]","title":"colormaps"},{"location":"v2_migration/#render","text":"In rio-tiler==1. * to create an image blob from an array we used the rio_tiler.utils.array_to_image function. We have renamed and slightly refactored the function but it works the same. # v1 img = rio_tiler . utils . array_to_image ( tile , mask , img_format = \"PNG\" ) # v2 img = rio_tiler . utils . render ( tile , mask , img_format = \"PNG\" )","title":"render"},{"location":"v2_migration/#mission-specific-changes","text":"Mission-specific tilers have been moved to the rio-tiler-pds package. Each rio_tiler.io.{mission} scene id parser (e.g cbers_parser) has been refactored and now return AWS S3 path information. rio_tiler . io . landsat8 . landsat_parser ( \"LC08_L1TP_016037_20170813_20170814_01_RT\" )) { \"sensor\" : \"C\" , \"satellite\" : \"08\" , \"processingCorrectionLevel\" : \"L1TP\" , \"path\" : \"016\" , \"row\" : \"037\" , \"acquisitionYear\" : \"2017\" , \"acquisitionMonth\" : \"08\" , \"acquisitionDay\" : \"13\" , \"processingYear\" : \"2017\" , \"processingMonth\" : \"08\" , \"processingDay\" : \"14\" , \"collectionNumber\" : \"01\" , \"collectionCategory\" : \"RT\" , \"scene\" : \"LC08_L1TP_016037_20170813_20170814_01_RT\" , \"date\" : \"2017-08-13\" , --> \"scheme\" : \"s3\" , --> \"bucket\" : \"landsat-pds\" , --> \"prefix\" : \"c1/L8/016/037/LC08_L1TP_016037_20170813_20170814_01_RT\" }","title":"Mission specific changes"},{"location":"rio_tiler/colormap/","text":"Module rio_tiler.colormap \u00b6 rio-tiler colormap functions. Variables \u00b6 EMPTY_COLORMAP cmap Functions \u00b6 apply_cmap \u00b6 def apply_cmap ( data : numpy . ndarray , colormap : Dict ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Apply colormap on tile data. Attributes ---------- data : numpy ndarray 1D image array to translate to RGB. colormap : dict GDAL RGBA Color Table dictionary. Returns ------- data : numpy.ndarray RGB data. mask: numpy.ndarray Alpha band. apply_discrete_cmap \u00b6 def apply_discrete_cmap ( data : numpy . ndarray , colormap : Dict ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Apply discrete colormap. Note: This method is not used by default and left to users to use within custom render methods. Attributes ---------- data : numpy ndarray 1D image array to translate to RGB. color_map: dict Discrete ColorMap dictionary e.g: { 1: [255, 255, 255], 2: [255, 0, 0] } Returns ------- arr: numpy.ndarray get_colormap \u00b6 def get_colormap ( name : str ) -> Dict Return colormap dict. Attributes ---------- name : str, optional Colormap name (default: cfastie) Returns ------- colormap : dict GDAL RGBA Color Table dictionary. make_lut \u00b6 def make_lut ( colormap : Dict ) -> numpy . ndarray Create a lookup table numpy.ndarray from a GDAL RGBA Color Table dictionary. Attributes ---------- colormap : dict GDAL RGBA Color Table dictionary. Returns ------- lut : numpy.ndarray colormap lookup table Classes \u00b6 ColorMaps \u00b6 class ColorMaps ( ) Default Colormaps holder. Methods \u00b6 get \u00b6 def get ( self , name : str ) -> Dict Fetch a colormap. list \u00b6 def list ( self ) -> List [ str ] List registered Colormaps. register \u00b6 def register ( self , name : str , custom_cmap : Union [ Dict , str ] ) Register a custom colormap. Attributes ---------- name : str Name of the colormap. custom_cmap: dict or str A dict or a path to a numpy file","title":"Colormap"},{"location":"rio_tiler/colormap/#module-rio_tilercolormap","text":"rio-tiler colormap functions.","title":"Module rio_tiler.colormap"},{"location":"rio_tiler/colormap/#variables","text":"EMPTY_COLORMAP cmap","title":"Variables"},{"location":"rio_tiler/colormap/#functions","text":"","title":"Functions"},{"location":"rio_tiler/colormap/#apply_cmap","text":"def apply_cmap ( data : numpy . ndarray , colormap : Dict ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Apply colormap on tile data. Attributes ---------- data : numpy ndarray 1D image array to translate to RGB. colormap : dict GDAL RGBA Color Table dictionary. Returns ------- data : numpy.ndarray RGB data. mask: numpy.ndarray Alpha band.","title":"apply_cmap"},{"location":"rio_tiler/colormap/#apply_discrete_cmap","text":"def apply_discrete_cmap ( data : numpy . ndarray , colormap : Dict ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Apply discrete colormap. Note: This method is not used by default and left to users to use within custom render methods. Attributes ---------- data : numpy ndarray 1D image array to translate to RGB. color_map: dict Discrete ColorMap dictionary e.g: { 1: [255, 255, 255], 2: [255, 0, 0] } Returns ------- arr: numpy.ndarray","title":"apply_discrete_cmap"},{"location":"rio_tiler/colormap/#get_colormap","text":"def get_colormap ( name : str ) -> Dict Return colormap dict. Attributes ---------- name : str, optional Colormap name (default: cfastie) Returns ------- colormap : dict GDAL RGBA Color Table dictionary.","title":"get_colormap"},{"location":"rio_tiler/colormap/#make_lut","text":"def make_lut ( colormap : Dict ) -> numpy . ndarray Create a lookup table numpy.ndarray from a GDAL RGBA Color Table dictionary. Attributes ---------- colormap : dict GDAL RGBA Color Table dictionary. Returns ------- lut : numpy.ndarray colormap lookup table","title":"make_lut"},{"location":"rio_tiler/colormap/#classes","text":"","title":"Classes"},{"location":"rio_tiler/colormap/#colormaps","text":"class ColorMaps ( ) Default Colormaps holder.","title":"ColorMaps"},{"location":"rio_tiler/colormap/#methods","text":"","title":"Methods"},{"location":"rio_tiler/colormap/#get","text":"def get ( self , name : str ) -> Dict Fetch a colormap.","title":"get"},{"location":"rio_tiler/colormap/#list","text":"def list ( self ) -> List [ str ] List registered Colormaps.","title":"list"},{"location":"rio_tiler/colormap/#register","text":"def register ( self , name : str , custom_cmap : Union [ Dict , str ] ) Register a custom colormap. Attributes ---------- name : str Name of the colormap. custom_cmap: dict or str A dict or a path to a numpy file","title":"register"},{"location":"rio_tiler/constants/","text":"Module rio_tiler.constants \u00b6 rio-tiler constant values. Variables \u00b6 MAX_THREADS WEB_MERCATOR_CRS WGS84_CRS","title":"Constants"},{"location":"rio_tiler/constants/#module-rio_tilerconstants","text":"rio-tiler constant values.","title":"Module rio_tiler.constants"},{"location":"rio_tiler/constants/#variables","text":"MAX_THREADS WEB_MERCATOR_CRS WGS84_CRS","title":"Variables"},{"location":"rio_tiler/errors/","text":"Module rio_tiler.errors \u00b6 Errors and warnings. Classes \u00b6 AlphaBandWarning \u00b6 class AlphaBandWarning ( / , * args , ** kwargs ) Automaticaly removed Alpha band from output array. Ancestors (in MRO) \u00b6 builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. DeprecationWarning \u00b6 class DeprecationWarning ( / , * args , ** kwargs ) Rio-tiler module deprecations warning. Ancestors (in MRO) \u00b6 builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. ExpressionMixingWarning \u00b6 class ExpressionMixingWarning ( / , * args , ** kwargs ) Expression and assets/indexes mixing. Ancestors (in MRO) \u00b6 builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. InvalidAssetName \u00b6 class InvalidAssetName ( / , * args , ** kwargs ) Invalid Asset name. Ancestors (in MRO) \u00b6 rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. InvalidBandName \u00b6 class InvalidBandName ( / , * args , ** kwargs ) Invalid band name. Ancestors (in MRO) \u00b6 rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. InvalidColorMapName \u00b6 class InvalidColorMapName ( / , * args , ** kwargs ) Invalid colormap name. Ancestors (in MRO) \u00b6 builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. InvalidFormat \u00b6 class InvalidFormat ( / , * args , ** kwargs ) Invalid image format. Ancestors (in MRO) \u00b6 rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. MissingAssets \u00b6 class MissingAssets ( / , * args , ** kwargs ) Missing Assets. Ancestors (in MRO) \u00b6 rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. NoOverviewWarning \u00b6 class NoOverviewWarning ( / , * args , ** kwargs ) Dataset has no overviews. Ancestors (in MRO) \u00b6 builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. PointOutsideBounds \u00b6 class PointOutsideBounds ( / , * args , ** kwargs ) Point is outside image bounds. Ancestors (in MRO) \u00b6 rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. RioTilerError \u00b6 class RioTilerError ( / , * args , ** kwargs ) Base exception class. Ancestors (in MRO) \u00b6 builtins.Exception builtins.BaseException Descendants \u00b6 rio_tiler.errors.InvalidFormat rio_tiler.errors.TileOutsideBounds rio_tiler.errors.PointOutsideBounds rio_tiler.errors.InvalidBandName rio_tiler.errors.InvalidAssetName rio_tiler.errors.MissingAssets Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self. TileOutsideBounds \u00b6 class TileOutsideBounds ( / , * args , ** kwargs ) Z-X-Y Tile is outside image bounds. Ancestors (in MRO) \u00b6 rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException Class variables \u00b6 args Methods \u00b6 with_traceback \u00b6 def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"Errors"},{"location":"rio_tiler/errors/#module-rio_tilererrors","text":"Errors and warnings.","title":"Module rio_tiler.errors"},{"location":"rio_tiler/errors/#classes","text":"","title":"Classes"},{"location":"rio_tiler/errors/#alphabandwarning","text":"class AlphaBandWarning ( / , * args , ** kwargs ) Automaticaly removed Alpha band from output array.","title":"AlphaBandWarning"},{"location":"rio_tiler/errors/#ancestors-in-mro","text":"builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#deprecationwarning","text":"class DeprecationWarning ( / , * args , ** kwargs ) Rio-tiler module deprecations warning.","title":"DeprecationWarning"},{"location":"rio_tiler/errors/#ancestors-in-mro_1","text":"builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_1","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_1","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_1","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#expressionmixingwarning","text":"class ExpressionMixingWarning ( / , * args , ** kwargs ) Expression and assets/indexes mixing.","title":"ExpressionMixingWarning"},{"location":"rio_tiler/errors/#ancestors-in-mro_2","text":"builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_2","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_2","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_2","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#invalidassetname","text":"class InvalidAssetName ( / , * args , ** kwargs ) Invalid Asset name.","title":"InvalidAssetName"},{"location":"rio_tiler/errors/#ancestors-in-mro_3","text":"rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_3","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_3","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_3","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#invalidbandname","text":"class InvalidBandName ( / , * args , ** kwargs ) Invalid band name.","title":"InvalidBandName"},{"location":"rio_tiler/errors/#ancestors-in-mro_4","text":"rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_4","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_4","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_4","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#invalidcolormapname","text":"class InvalidColorMapName ( / , * args , ** kwargs ) Invalid colormap name.","title":"InvalidColorMapName"},{"location":"rio_tiler/errors/#ancestors-in-mro_5","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_5","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_5","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_5","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#invalidformat","text":"class InvalidFormat ( / , * args , ** kwargs ) Invalid image format.","title":"InvalidFormat"},{"location":"rio_tiler/errors/#ancestors-in-mro_6","text":"rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_6","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_6","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_6","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#missingassets","text":"class MissingAssets ( / , * args , ** kwargs ) Missing Assets.","title":"MissingAssets"},{"location":"rio_tiler/errors/#ancestors-in-mro_7","text":"rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_7","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_7","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_7","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#nooverviewwarning","text":"class NoOverviewWarning ( / , * args , ** kwargs ) Dataset has no overviews.","title":"NoOverviewWarning"},{"location":"rio_tiler/errors/#ancestors-in-mro_8","text":"builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_8","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_8","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_8","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#pointoutsidebounds","text":"class PointOutsideBounds ( / , * args , ** kwargs ) Point is outside image bounds.","title":"PointOutsideBounds"},{"location":"rio_tiler/errors/#ancestors-in-mro_9","text":"rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_9","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_9","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_9","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#riotilererror","text":"class RioTilerError ( / , * args , ** kwargs ) Base exception class.","title":"RioTilerError"},{"location":"rio_tiler/errors/#ancestors-in-mro_10","text":"builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#descendants","text":"rio_tiler.errors.InvalidFormat rio_tiler.errors.TileOutsideBounds rio_tiler.errors.PointOutsideBounds rio_tiler.errors.InvalidBandName rio_tiler.errors.InvalidAssetName rio_tiler.errors.MissingAssets","title":"Descendants"},{"location":"rio_tiler/errors/#class-variables_10","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_10","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_10","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/errors/#tileoutsidebounds","text":"class TileOutsideBounds ( / , * args , ** kwargs ) Z-X-Y Tile is outside image bounds.","title":"TileOutsideBounds"},{"location":"rio_tiler/errors/#ancestors-in-mro_11","text":"rio_tiler.errors.RioTilerError builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"rio_tiler/errors/#class-variables_11","text":"args","title":"Class variables"},{"location":"rio_tiler/errors/#methods_11","text":"","title":"Methods"},{"location":"rio_tiler/errors/#with_traceback_11","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self.__traceback__ to tb and return self.","title":"with_traceback"},{"location":"rio_tiler/expression/","text":"Module rio_tiler.expression \u00b6 rio-tiler.expression: Parse and Apply expression. Functions \u00b6 apply_expression \u00b6 def apply_expression ( blocks : Sequence [ str ], bands : Sequence [ Union [ str , int ]], data : numpy . ndarray ) -> numpy . ndarray Apply rio-tiler expression. Attributes ---------- blocks: Tuple or List expression for a specific layer. bands: Tuple or List bands names. data: numpy.array array of bands. Returns ------- data: numpy.array parse_expression \u00b6 def parse_expression ( expression : str , cast : bool = True ) -> Tuple Parse rio-tiler band math expression. Attributes ---------- expression: str band math/combination expression (e.g b3/b2). Returns ------- bands: Tuple","title":"Expression"},{"location":"rio_tiler/expression/#module-rio_tilerexpression","text":"rio-tiler.expression: Parse and Apply expression.","title":"Module rio_tiler.expression"},{"location":"rio_tiler/expression/#functions","text":"","title":"Functions"},{"location":"rio_tiler/expression/#apply_expression","text":"def apply_expression ( blocks : Sequence [ str ], bands : Sequence [ Union [ str , int ]], data : numpy . ndarray ) -> numpy . ndarray Apply rio-tiler expression. Attributes ---------- blocks: Tuple or List expression for a specific layer. bands: Tuple or List bands names. data: numpy.array array of bands. Returns ------- data: numpy.array","title":"apply_expression"},{"location":"rio_tiler/expression/#parse_expression","text":"def parse_expression ( expression : str , cast : bool = True ) -> Tuple Parse rio-tiler band math expression. Attributes ---------- expression: str band math/combination expression (e.g b3/b2). Returns ------- bands: Tuple","title":"parse_expression"},{"location":"rio_tiler/mercator/","text":"Module rio_tiler.mercator \u00b6 rio-tiler: mercator utility functions. Functions \u00b6 get_zooms \u00b6 def get_zooms ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], ensure_global_max_zoom : bool = False , tilesize : int = 256 ) -> Tuple [ int , int ] Calculate raster min/max mercator zoom level. Parameters ---------- src_dst: rasterio.io.DatasetReader Rasterio io.DatasetReader object ensure_global_max_zoom: bool, optional Apply latitude correction factor to ensure max_zoom equality for global datasets covering different latitudes (default: False). tilesize: int, optional Mercator tile size (default: 256). Returns ------- min_zoom, max_zoom: Tuple Min/Max Mercator zoom levels. zoom_for_pixelsize \u00b6 def zoom_for_pixelsize ( pixel_size : float , max_z : int = 24 , tilesize : int = 256 ) -> int Get mercator zoom level corresponding to a pixel resolution. Freely adapted from https://github.com/OSGeo/gdal/blob/b0dfc591929ebdbccd8a0557510c5efdb893b852/gdal/swig/python/scripts/gdal2tiles.py#L294 Parameters ---------- pixel_size: float Pixel size max_z: int, optional (default: 24) Max mercator zoom level allowed tilesize: int, optional Mercator tile size (default: 256). Returns ------- Mercator zoom level corresponding to the pixel resolution","title":"Mercator"},{"location":"rio_tiler/mercator/#module-rio_tilermercator","text":"rio-tiler: mercator utility functions.","title":"Module rio_tiler.mercator"},{"location":"rio_tiler/mercator/#functions","text":"","title":"Functions"},{"location":"rio_tiler/mercator/#get_zooms","text":"def get_zooms ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], ensure_global_max_zoom : bool = False , tilesize : int = 256 ) -> Tuple [ int , int ] Calculate raster min/max mercator zoom level. Parameters ---------- src_dst: rasterio.io.DatasetReader Rasterio io.DatasetReader object ensure_global_max_zoom: bool, optional Apply latitude correction factor to ensure max_zoom equality for global datasets covering different latitudes (default: False). tilesize: int, optional Mercator tile size (default: 256). Returns ------- min_zoom, max_zoom: Tuple Min/Max Mercator zoom levels.","title":"get_zooms"},{"location":"rio_tiler/mercator/#zoom_for_pixelsize","text":"def zoom_for_pixelsize ( pixel_size : float , max_z : int = 24 , tilesize : int = 256 ) -> int Get mercator zoom level corresponding to a pixel resolution. Freely adapted from https://github.com/OSGeo/gdal/blob/b0dfc591929ebdbccd8a0557510c5efdb893b852/gdal/swig/python/scripts/gdal2tiles.py#L294 Parameters ---------- pixel_size: float Pixel size max_z: int, optional (default: 24) Max mercator zoom level allowed tilesize: int, optional Mercator tile size (default: 256). Returns ------- Mercator zoom level corresponding to the pixel resolution","title":"zoom_for_pixelsize"},{"location":"rio_tiler/profiles/","text":"Module rio_tiler.profiles \u00b6 Image file profiles. Variables \u00b6 img_profiles Classes \u00b6 ImagesProfiles \u00b6 class ImagesProfiles ( ) GDAL Image creation options. ref: https://github.com/mapnik/mapnik/wiki/Image-IO#default-output-details. Ancestors (in MRO) \u00b6 collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container Static methods \u00b6 fromkeys \u00b6 def fromkeys ( iterable , value = None ) Methods \u00b6 clear \u00b6 def clear ( self ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( self ) get \u00b6 def get ( self , key , default = None ) Like normal item access but return a copy of the key. items \u00b6 def items ( self ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( self ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem \u00b6 def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. setdefault \u00b6 def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D update \u00b6 def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v values \u00b6 def values ( self ) D.values() -> an object providing a view on D's values JPEGProfile \u00b6 class JPEGProfile ( data = {}, ** kwds ) JPEG creation options ref: https://www.gdal.org/frmt_jpeg.html. Ancestors (in MRO) \u00b6 rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container Class variables \u00b6 defaults Static methods \u00b6 fromkeys \u00b6 def fromkeys ( iterable , value = None ) Methods \u00b6 clear \u00b6 def clear ( self ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( self ) get \u00b6 def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. items \u00b6 def items ( self ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( self ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem \u00b6 def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. setdefault \u00b6 def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D update \u00b6 def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v values \u00b6 def values ( self ) D.values() -> an object providing a view on D's values PNGProfile \u00b6 class PNGProfile ( data = {}, ** kwds ) PNG creation options ref: https://www.gdal.org/frmt_png.html. Ancestors (in MRO) \u00b6 rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container Class variables \u00b6 defaults Static methods \u00b6 fromkeys \u00b6 def fromkeys ( iterable , value = None ) Methods \u00b6 clear \u00b6 def clear ( self ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( self ) get \u00b6 def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. items \u00b6 def items ( self ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( self ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem \u00b6 def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. setdefault \u00b6 def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D update \u00b6 def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v values \u00b6 def values ( self ) D.values() -> an object providing a view on D's values PNGRAWProfile \u00b6 class PNGRAWProfile ( data = {}, ** kwds ) PNG creation options ref: https://www.gdal.org/frmt_png.html. Ancestors (in MRO) \u00b6 rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container Class variables \u00b6 defaults Static methods \u00b6 fromkeys \u00b6 def fromkeys ( iterable , value = None ) Methods \u00b6 clear \u00b6 def clear ( self ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( self ) get \u00b6 def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. items \u00b6 def items ( self ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( self ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem \u00b6 def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. setdefault \u00b6 def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D update \u00b6 def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v values \u00b6 def values ( self ) D.values() -> an object providing a view on D's values WEBPProfile \u00b6 class WEBPProfile ( data = {}, ** kwds ) WEBP creation options ref: https://www.gdal.org/frmt_webp.html. Ancestors (in MRO) \u00b6 rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container Class variables \u00b6 defaults Static methods \u00b6 fromkeys \u00b6 def fromkeys ( iterable , value = None ) Methods \u00b6 clear \u00b6 def clear ( self ) D.clear() -> None. Remove all items from D. copy \u00b6 def copy ( self ) get \u00b6 def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None. items \u00b6 def items ( self ) D.items() -> a set-like object providing a view on D's items keys \u00b6 def keys ( self ) D.keys() -> a set-like object providing a view on D's keys pop \u00b6 def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised. popitem \u00b6 def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty. setdefault \u00b6 def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D update \u00b6 def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v values \u00b6 def values ( self ) D.values() -> an object providing a view on D's values","title":"Profiles"},{"location":"rio_tiler/profiles/#module-rio_tilerprofiles","text":"Image file profiles.","title":"Module rio_tiler.profiles"},{"location":"rio_tiler/profiles/#variables","text":"img_profiles","title":"Variables"},{"location":"rio_tiler/profiles/#classes","text":"","title":"Classes"},{"location":"rio_tiler/profiles/#imagesprofiles","text":"class ImagesProfiles ( ) GDAL Image creation options. ref: https://github.com/mapnik/mapnik/wiki/Image-IO#default-output-details.","title":"ImagesProfiles"},{"location":"rio_tiler/profiles/#ancestors-in-mro","text":"collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container","title":"Ancestors (in MRO)"},{"location":"rio_tiler/profiles/#static-methods","text":"","title":"Static methods"},{"location":"rio_tiler/profiles/#fromkeys","text":"def fromkeys ( iterable , value = None )","title":"fromkeys"},{"location":"rio_tiler/profiles/#methods","text":"","title":"Methods"},{"location":"rio_tiler/profiles/#clear","text":"def clear ( self ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"rio_tiler/profiles/#copy","text":"def copy ( self )","title":"copy"},{"location":"rio_tiler/profiles/#get","text":"def get ( self , key , default = None ) Like normal item access but return a copy of the key.","title":"get"},{"location":"rio_tiler/profiles/#items","text":"def items ( self ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"rio_tiler/profiles/#keys","text":"def keys ( self ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"rio_tiler/profiles/#pop","text":"def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.","title":"pop"},{"location":"rio_tiler/profiles/#popitem","text":"def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.","title":"popitem"},{"location":"rio_tiler/profiles/#setdefault","text":"def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D","title":"setdefault"},{"location":"rio_tiler/profiles/#update","text":"def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v","title":"update"},{"location":"rio_tiler/profiles/#values","text":"def values ( self ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"rio_tiler/profiles/#jpegprofile","text":"class JPEGProfile ( data = {}, ** kwds ) JPEG creation options ref: https://www.gdal.org/frmt_jpeg.html.","title":"JPEGProfile"},{"location":"rio_tiler/profiles/#ancestors-in-mro_1","text":"rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container","title":"Ancestors (in MRO)"},{"location":"rio_tiler/profiles/#class-variables","text":"defaults","title":"Class variables"},{"location":"rio_tiler/profiles/#static-methods_1","text":"","title":"Static methods"},{"location":"rio_tiler/profiles/#fromkeys_1","text":"def fromkeys ( iterable , value = None )","title":"fromkeys"},{"location":"rio_tiler/profiles/#methods_1","text":"","title":"Methods"},{"location":"rio_tiler/profiles/#clear_1","text":"def clear ( self ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"rio_tiler/profiles/#copy_1","text":"def copy ( self )","title":"copy"},{"location":"rio_tiler/profiles/#get_1","text":"def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.","title":"get"},{"location":"rio_tiler/profiles/#items_1","text":"def items ( self ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"rio_tiler/profiles/#keys_1","text":"def keys ( self ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"rio_tiler/profiles/#pop_1","text":"def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.","title":"pop"},{"location":"rio_tiler/profiles/#popitem_1","text":"def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.","title":"popitem"},{"location":"rio_tiler/profiles/#setdefault_1","text":"def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D","title":"setdefault"},{"location":"rio_tiler/profiles/#update_1","text":"def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v","title":"update"},{"location":"rio_tiler/profiles/#values_1","text":"def values ( self ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"rio_tiler/profiles/#pngprofile","text":"class PNGProfile ( data = {}, ** kwds ) PNG creation options ref: https://www.gdal.org/frmt_png.html.","title":"PNGProfile"},{"location":"rio_tiler/profiles/#ancestors-in-mro_2","text":"rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container","title":"Ancestors (in MRO)"},{"location":"rio_tiler/profiles/#class-variables_1","text":"defaults","title":"Class variables"},{"location":"rio_tiler/profiles/#static-methods_2","text":"","title":"Static methods"},{"location":"rio_tiler/profiles/#fromkeys_2","text":"def fromkeys ( iterable , value = None )","title":"fromkeys"},{"location":"rio_tiler/profiles/#methods_2","text":"","title":"Methods"},{"location":"rio_tiler/profiles/#clear_2","text":"def clear ( self ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"rio_tiler/profiles/#copy_2","text":"def copy ( self )","title":"copy"},{"location":"rio_tiler/profiles/#get_2","text":"def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.","title":"get"},{"location":"rio_tiler/profiles/#items_2","text":"def items ( self ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"rio_tiler/profiles/#keys_2","text":"def keys ( self ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"rio_tiler/profiles/#pop_2","text":"def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.","title":"pop"},{"location":"rio_tiler/profiles/#popitem_2","text":"def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.","title":"popitem"},{"location":"rio_tiler/profiles/#setdefault_2","text":"def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D","title":"setdefault"},{"location":"rio_tiler/profiles/#update_2","text":"def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v","title":"update"},{"location":"rio_tiler/profiles/#values_2","text":"def values ( self ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"rio_tiler/profiles/#pngrawprofile","text":"class PNGRAWProfile ( data = {}, ** kwds ) PNG creation options ref: https://www.gdal.org/frmt_png.html.","title":"PNGRAWProfile"},{"location":"rio_tiler/profiles/#ancestors-in-mro_3","text":"rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container","title":"Ancestors (in MRO)"},{"location":"rio_tiler/profiles/#class-variables_2","text":"defaults","title":"Class variables"},{"location":"rio_tiler/profiles/#static-methods_3","text":"","title":"Static methods"},{"location":"rio_tiler/profiles/#fromkeys_3","text":"def fromkeys ( iterable , value = None )","title":"fromkeys"},{"location":"rio_tiler/profiles/#methods_3","text":"","title":"Methods"},{"location":"rio_tiler/profiles/#clear_3","text":"def clear ( self ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"rio_tiler/profiles/#copy_3","text":"def copy ( self )","title":"copy"},{"location":"rio_tiler/profiles/#get_3","text":"def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.","title":"get"},{"location":"rio_tiler/profiles/#items_3","text":"def items ( self ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"rio_tiler/profiles/#keys_3","text":"def keys ( self ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"rio_tiler/profiles/#pop_3","text":"def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.","title":"pop"},{"location":"rio_tiler/profiles/#popitem_3","text":"def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.","title":"popitem"},{"location":"rio_tiler/profiles/#setdefault_3","text":"def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D","title":"setdefault"},{"location":"rio_tiler/profiles/#update_3","text":"def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v","title":"update"},{"location":"rio_tiler/profiles/#values_3","text":"def values ( self ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"rio_tiler/profiles/#webpprofile","text":"class WEBPProfile ( data = {}, ** kwds ) WEBP creation options ref: https://www.gdal.org/frmt_webp.html.","title":"WEBPProfile"},{"location":"rio_tiler/profiles/#ancestors-in-mro_4","text":"rasterio.profiles.Profile collections.UserDict collections.abc.MutableMapping collections.abc.Mapping collections.abc.Collection collections.abc.Sized collections.abc.Iterable collections.abc.Container","title":"Ancestors (in MRO)"},{"location":"rio_tiler/profiles/#class-variables_3","text":"defaults","title":"Class variables"},{"location":"rio_tiler/profiles/#static-methods_4","text":"","title":"Static methods"},{"location":"rio_tiler/profiles/#fromkeys_4","text":"def fromkeys ( iterable , value = None )","title":"fromkeys"},{"location":"rio_tiler/profiles/#methods_4","text":"","title":"Methods"},{"location":"rio_tiler/profiles/#clear_4","text":"def clear ( self ) D.clear() -> None. Remove all items from D.","title":"clear"},{"location":"rio_tiler/profiles/#copy_4","text":"def copy ( self )","title":"copy"},{"location":"rio_tiler/profiles/#get_4","text":"def get ( self , key , default = None ) D.get(k[,d]) -> D[k] if k in D, else d. d defaults to None.","title":"get"},{"location":"rio_tiler/profiles/#items_4","text":"def items ( self ) D.items() -> a set-like object providing a view on D's items","title":"items"},{"location":"rio_tiler/profiles/#keys_4","text":"def keys ( self ) D.keys() -> a set-like object providing a view on D's keys","title":"keys"},{"location":"rio_tiler/profiles/#pop_4","text":"def pop ( self , key , default =< object object at 0x7fe553574130 > ) D.pop(k[,d]) -> v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.","title":"pop"},{"location":"rio_tiler/profiles/#popitem_4","text":"def popitem ( self ) D.popitem() -> (k, v), remove and return some (key, value) pair as a 2-tuple; but raise KeyError if D is empty.","title":"popitem"},{"location":"rio_tiler/profiles/#setdefault_4","text":"def setdefault ( self , key , default = None ) D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D","title":"setdefault"},{"location":"rio_tiler/profiles/#update_4","text":"def update ( * args , ** kwds ) D.update([E, ]**F) -> None. Update D from mapping/iterable E and F. If E present and has a .keys() method, does: for k in E: D[k] = E[k] If E present and lacks .keys() method, does: for (k, v) in E: D[k] = v In either case, this is followed by: for k, v in F.items(): D[k] = v","title":"update"},{"location":"rio_tiler/profiles/#values_4","text":"def values ( self ) D.values() -> an object providing a view on D's values","title":"values"},{"location":"rio_tiler/reader/","text":"Module rio_tiler.reader \u00b6 rio-tiler.reader: image utility functions. Functions \u00b6 metadata \u00b6 def metadata ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Union [ Tuple [ float , float , float , float ], NoneType ] = None , indexes : Union [ Sequence [ int ], int , NoneType ] = None , max_size : int = 1024 , bounds_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), percentiles : Tuple [ float , float ] = ( 2.0 , 98.0 ), hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Retrieve metadata and statistics from an image. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object bounds : tuple, optional Bounding box coordinates from which to calculate image statistics. max_size : int `max_size` of the longest dimension, respecting bounds X/Y aspect ratio. indexes : list of ints or a single int, optional Band indexes. bounds_crs: CRS or str, optional Specify bounds coordinate reference system, default WGS84/EPSG4326. percentiles: tuple, optional Tuple of Min/Max percentiles to compute. Default is (2, 98). hist_options : dict, optional Options to forward to numpy.histogram function. kwargs : Any, optional Additional options to forward to part or preview Returns ------- dict part \u00b6 def part ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Tuple [ float , float , float , float ], height : Union [ int , NoneType ] = None , width : Union [ int , NoneType ] = None , padding : int = 0 , dst_crs : Union [ rasterio . crs . CRS , NoneType ] = None , bounds_crs : Union [ rasterio . crs . CRS , NoneType ] = None , minimum_overlap : Union [ float , NoneType ] = None , warp_vrt_option : Union [ Dict , NoneType ] = None , vrt_options : Union [ Dict , NoneType ] = None , max_size : Union [ int , NoneType ] = None , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of an image. Attributes ---------- src_dst: rasterio.io.DatasetReader rasterio.io.DatasetReader object bounds: tuple Output bounds (left, bottom, right, top) in target crs (\"dst_crs\"). height: int, optional Output height of the array. width: int, optional Output width of the array. padding: int, optional Padding to apply to each edge of the tile when retrieving data to assist in reducing resampling artefacts along edges. dst_crs: CRS or str, optional Target coordinate reference system, default is \"epsg:3857\". bounds_crs: CRS or str, optional Overwrite bounds coordinate reference system, default is equal to the output CRS (dst_crs). minimum_tile_cover: float, optional Minimum % overlap for which to raise an error with dataset not covering enought of the tile. warp_vrt_option: dict, DEPRECATED These will be passed to the rasterio.warp.WarpedVRT class. vrt_options: dict, optional These will be passed to the rasterio.warp.WarpedVRT class. max_size: int, optional Limit output size array if not widht and height. kwargs: Any, optional Additional options to forward to reader._read() Returns ------- data : numpy ndarray mask: numpy array point \u00b6 def point ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], coordinates : Tuple [ float , float ], indexes : Union [ Sequence [ int ], int , NoneType ] = None , coord_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), nodata : Union [ float , int , str , NoneType ] = None , unscale : bool = False , masked : bool = True , vrt_options : Union [ Dict , NoneType ] = None ) -> List Read point value Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object coordinates : tuple (X, Y) coordinates. indexes : list of ints or a single int, optional Band indexes coord_crs : rasterio.crs.CRS, optional (X, Y) coordinate system. Default is WGS84/EPSG:4326. nodata: int or float, optional unscale, bool, optional If True, apply scale and offset to the data. Default is set to False. masked : bool Whether to mask samples that fall outside the extent of the dataset. Default is set to True. vrt_options: dict, optional These will be passed to the rasterio.warp.WarpedVRT class. Returns ------- point : list List of pixel values per bands indexes. preview \u00b6 def preview ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], max_size : int = 1024 , height : int = None , width : int = None , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read image and resample to low resolution. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object max_size : int `max_size` of the longest dimension, respecting bounds X/Y aspect ratio. height: int, optional output height of the data width: int, optional output width of the data kwargs : Any, optional Additional options to forward to reader._read() Returns ------- data : numpy ndarray mask: numpy array stats \u00b6 def stats ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Union [ Tuple [ float , float , float , float ], NoneType ] = None , indexes : Union [ Sequence [ int ], int , NoneType ] = None , max_size : int = 1024 , bounds_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), percentiles : Tuple [ float , float ] = ( 2.0 , 98.0 ), hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Retrieve statistics from an image. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object bounds : tuple, optional Bounding box coordinates from which to calculate image statistics. max_size : int `max_size` of the longest dimension, respecting bounds X/Y aspect ratio. indexes : list of ints or a single int, optional Band indexes. bounds_crs: CRS or str, optional Specify bounds coordinate reference system, default WGS84/EPSG4326. percentiles: tuple, optional Tuple of Min/Max percentiles to compute. Default is (2, 98). hist_options : dict, optional Options to forward to numpy.histogram function. kwargs : Any, optional Additional options to forward to part or preview Returns ------- dict tile \u00b6 def tile ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], x : int , y : int , z : int , tilesize : int = 256 , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read mercator tile from an image. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object x : int Mercator tile X index. y : int Mercator tile Y index. z : int Mercator tile ZOOM level. tilesize : int, optional Output tile size. Default is 256. kwargs : Any, optional Additional options to forward to part() Returns ------- data : numpy ndarray mask: numpy array","title":"Reader"},{"location":"rio_tiler/reader/#module-rio_tilerreader","text":"rio-tiler.reader: image utility functions.","title":"Module rio_tiler.reader"},{"location":"rio_tiler/reader/#functions","text":"","title":"Functions"},{"location":"rio_tiler/reader/#metadata","text":"def metadata ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Union [ Tuple [ float , float , float , float ], NoneType ] = None , indexes : Union [ Sequence [ int ], int , NoneType ] = None , max_size : int = 1024 , bounds_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), percentiles : Tuple [ float , float ] = ( 2.0 , 98.0 ), hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Retrieve metadata and statistics from an image. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object bounds : tuple, optional Bounding box coordinates from which to calculate image statistics. max_size : int `max_size` of the longest dimension, respecting bounds X/Y aspect ratio. indexes : list of ints or a single int, optional Band indexes. bounds_crs: CRS or str, optional Specify bounds coordinate reference system, default WGS84/EPSG4326. percentiles: tuple, optional Tuple of Min/Max percentiles to compute. Default is (2, 98). hist_options : dict, optional Options to forward to numpy.histogram function. kwargs : Any, optional Additional options to forward to part or preview Returns ------- dict","title":"metadata"},{"location":"rio_tiler/reader/#part","text":"def part ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Tuple [ float , float , float , float ], height : Union [ int , NoneType ] = None , width : Union [ int , NoneType ] = None , padding : int = 0 , dst_crs : Union [ rasterio . crs . CRS , NoneType ] = None , bounds_crs : Union [ rasterio . crs . CRS , NoneType ] = None , minimum_overlap : Union [ float , NoneType ] = None , warp_vrt_option : Union [ Dict , NoneType ] = None , vrt_options : Union [ Dict , NoneType ] = None , max_size : Union [ int , NoneType ] = None , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of an image. Attributes ---------- src_dst: rasterio.io.DatasetReader rasterio.io.DatasetReader object bounds: tuple Output bounds (left, bottom, right, top) in target crs (\"dst_crs\"). height: int, optional Output height of the array. width: int, optional Output width of the array. padding: int, optional Padding to apply to each edge of the tile when retrieving data to assist in reducing resampling artefacts along edges. dst_crs: CRS or str, optional Target coordinate reference system, default is \"epsg:3857\". bounds_crs: CRS or str, optional Overwrite bounds coordinate reference system, default is equal to the output CRS (dst_crs). minimum_tile_cover: float, optional Minimum % overlap for which to raise an error with dataset not covering enought of the tile. warp_vrt_option: dict, DEPRECATED These will be passed to the rasterio.warp.WarpedVRT class. vrt_options: dict, optional These will be passed to the rasterio.warp.WarpedVRT class. max_size: int, optional Limit output size array if not widht and height. kwargs: Any, optional Additional options to forward to reader._read() Returns ------- data : numpy ndarray mask: numpy array","title":"part"},{"location":"rio_tiler/reader/#point","text":"def point ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], coordinates : Tuple [ float , float ], indexes : Union [ Sequence [ int ], int , NoneType ] = None , coord_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), nodata : Union [ float , int , str , NoneType ] = None , unscale : bool = False , masked : bool = True , vrt_options : Union [ Dict , NoneType ] = None ) -> List Read point value Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object coordinates : tuple (X, Y) coordinates. indexes : list of ints or a single int, optional Band indexes coord_crs : rasterio.crs.CRS, optional (X, Y) coordinate system. Default is WGS84/EPSG:4326. nodata: int or float, optional unscale, bool, optional If True, apply scale and offset to the data. Default is set to False. masked : bool Whether to mask samples that fall outside the extent of the dataset. Default is set to True. vrt_options: dict, optional These will be passed to the rasterio.warp.WarpedVRT class. Returns ------- point : list List of pixel values per bands indexes.","title":"point"},{"location":"rio_tiler/reader/#preview","text":"def preview ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], max_size : int = 1024 , height : int = None , width : int = None , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read image and resample to low resolution. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object max_size : int `max_size` of the longest dimension, respecting bounds X/Y aspect ratio. height: int, optional output height of the data width: int, optional output width of the data kwargs : Any, optional Additional options to forward to reader._read() Returns ------- data : numpy ndarray mask: numpy array","title":"preview"},{"location":"rio_tiler/reader/#stats","text":"def stats ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Union [ Tuple [ float , float , float , float ], NoneType ] = None , indexes : Union [ Sequence [ int ], int , NoneType ] = None , max_size : int = 1024 , bounds_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), percentiles : Tuple [ float , float ] = ( 2.0 , 98.0 ), hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Retrieve statistics from an image. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object bounds : tuple, optional Bounding box coordinates from which to calculate image statistics. max_size : int `max_size` of the longest dimension, respecting bounds X/Y aspect ratio. indexes : list of ints or a single int, optional Band indexes. bounds_crs: CRS or str, optional Specify bounds coordinate reference system, default WGS84/EPSG4326. percentiles: tuple, optional Tuple of Min/Max percentiles to compute. Default is (2, 98). hist_options : dict, optional Options to forward to numpy.histogram function. kwargs : Any, optional Additional options to forward to part or preview Returns ------- dict","title":"stats"},{"location":"rio_tiler/reader/#tile","text":"def tile ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], x : int , y : int , z : int , tilesize : int = 256 , ** kwargs ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read mercator tile from an image. Attributes ---------- src_dst : rasterio.io.DatasetReader rasterio.io.DatasetReader object x : int Mercator tile X index. y : int Mercator tile Y index. z : int Mercator tile ZOOM level. tilesize : int, optional Output tile size. Default is 256. kwargs : Any, optional Additional options to forward to part() Returns ------- data : numpy ndarray mask: numpy array","title":"tile"},{"location":"rio_tiler/tasks/","text":"Module rio_tiler.tasks \u00b6 rio_tiler.tasks: tools for handling rio-tiler's future tasks. Variables \u00b6 MAX_THREADS TaskType logger Functions \u00b6 create_tasks \u00b6 def create_tasks ( reader : Callable , assets , threads , * args , ** kwargs ) -> Union [ Generator [ Tuple [ Callable , str ], NoneType , NoneType ], Sequence [ Tuple [ concurrent . futures . _base . Future , str ]]] Create Future Tasks. filter_tasks \u00b6 def filter_tasks ( tasks : Union [ Generator [ Tuple [ Callable , str ], NoneType , NoneType ], Sequence [ Tuple [ concurrent . futures . _base . Future , str ]]], allowed_exceptions : Union [ Tuple , NoneType ] = None ) -> Generator Filter tasks to remove Exceptions. Attributes ---------- tasks: list or generator Sequence of 'concurrent.futures._base.Future' or 'callable' allowed_exceptions: Tuple, optional List of exceptions which won't be raised. Yields ------ Successful task's result multi_arrays \u00b6 def multi_arrays ( assets : Sequence [ str ], reader : Callable , * args : Any , threads : int = 80 , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Multi array. multi_values \u00b6 def multi_values ( assets : Sequence [ str ], reader : Callable , * args : Any , threads : int = 80 , ** kwargs : Any ) -> Dict Multi Values.","title":"Tasks"},{"location":"rio_tiler/tasks/#module-rio_tilertasks","text":"rio_tiler.tasks: tools for handling rio-tiler's future tasks.","title":"Module rio_tiler.tasks"},{"location":"rio_tiler/tasks/#variables","text":"MAX_THREADS TaskType logger","title":"Variables"},{"location":"rio_tiler/tasks/#functions","text":"","title":"Functions"},{"location":"rio_tiler/tasks/#create_tasks","text":"def create_tasks ( reader : Callable , assets , threads , * args , ** kwargs ) -> Union [ Generator [ Tuple [ Callable , str ], NoneType , NoneType ], Sequence [ Tuple [ concurrent . futures . _base . Future , str ]]] Create Future Tasks.","title":"create_tasks"},{"location":"rio_tiler/tasks/#filter_tasks","text":"def filter_tasks ( tasks : Union [ Generator [ Tuple [ Callable , str ], NoneType , NoneType ], Sequence [ Tuple [ concurrent . futures . _base . Future , str ]]], allowed_exceptions : Union [ Tuple , NoneType ] = None ) -> Generator Filter tasks to remove Exceptions. Attributes ---------- tasks: list or generator Sequence of 'concurrent.futures._base.Future' or 'callable' allowed_exceptions: Tuple, optional List of exceptions which won't be raised. Yields ------ Successful task's result","title":"filter_tasks"},{"location":"rio_tiler/tasks/#multi_arrays","text":"def multi_arrays ( assets : Sequence [ str ], reader : Callable , * args : Any , threads : int = 80 , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Multi array.","title":"multi_arrays"},{"location":"rio_tiler/tasks/#multi_values","text":"def multi_values ( assets : Sequence [ str ], reader : Callable , * args : Any , threads : int = 80 , ** kwargs : Any ) -> Dict Multi Values.","title":"multi_values"},{"location":"rio_tiler/utils/","text":"Module rio_tiler.utils \u00b6 rio_tiler.utils: utility functions. Variables \u00b6 DataSet Functions \u00b6 aws_get_object \u00b6 def aws_get_object ( bucket : str , key : str , request_pays : bool = False , client : < function Session . client at 0x7fe55aecb680 > = None ) -> bytes AWS s3 get object content. create_cutline \u00b6 def create_cutline ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], geometry : Dict , geometry_crs : rasterio . crs . CRS = None ) -> str Create WKT Polygon Cutline for GDALWarpOptions. Ref: https://gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions Attributes ---------- src_dst: rasterio.io.DatasetReader rasterio.io.DatasetReader object geometry: dict GeoJSON feature or GeoJSON geometry geometry_crs: CRS or str, optional Specify bounds coordinate reference system, default is same as input dataset. Returns ------- wkt: str Cutline WKT geometry in form of `POLYGON ((x y, x y, ...))) geotiff_options \u00b6 def geotiff_options ( x : int , y : int , z : int , tilesize : int = 256 , dst_crs : rasterio . crs . CRS = CRS . from_epsg ( 3857 ) ) -> Dict GeoTIFF options. Attributes ---------- x : int Mercator tile X index. y : int Mercator tile Y index. z : int Mercator tile ZOOM level. tilesize : int, optional Output tile size. Default is 256. dst_crs: CRS, optional Target coordinate reference system, default is \"epsg:3857\". Returns ------- dict get_overview_level \u00b6 def get_overview_level ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Tuple [ float , float , float , float ], height : int , width : int , dst_crs : rasterio . crs . CRS = CRS . from_epsg ( 3857 ) ) -> int Return the overview level corresponding to the tile resolution. Freely adapted from https://github.com/OSGeo/gdal/blob/41993f127e6e1669fbd9e944744b7c9b2bd6c400/gdal/apps/gdalwarp_lib.cpp#L2293-L2362 Attributes ---------- src_dst : rasterio.io.DatasetReader Rasterio io.DatasetReader object bounds : list Bounds (left, bottom, right, top) in target crs (\"dst_crs\"). height : int Output height. width : int Output width. dst_crs: CRS or str, optional Target coordinate reference system (default \"epsg:3857\"). Returns ------- ovr_idx: Int or None Overview level get_vrt_transform \u00b6 def get_vrt_transform ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Tuple [ float , float , float , float ], height : Union [ int , NoneType ] = None , width : Union [ int , NoneType ] = None , dst_crs : rasterio . crs . CRS = CRS . from_epsg ( 3857 ) ) -> Tuple [ affine . Affine , int , int ] Calculate VRT transform. Attributes ---------- src_dst : rasterio.io.DatasetReader Rasterio io.DatasetReader object bounds : list Bounds (left, bottom, right, top) in target crs (\"dst_crs\"). height : int, optional Desired output height of the array for the bounds. width : int, optional Desired output width of the array for the bounds. dst_crs: CRS or str, optional Target coordinate reference system (default \"epsg:3857\"). Returns ------- vrt_transform: Affine Output affine transformation matrix vrt_width, vrt_height: int Output dimensions has_alpha_band \u00b6 def has_alpha_band ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ] ) -> bool Check for alpha band or mask in source. has_mask_band \u00b6 def has_mask_band ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ] ) -> bool Check for mask band in source. linear_rescale \u00b6 def linear_rescale ( image : numpy . ndarray , in_range : Tuple [ Union [ int , float ], Union [ int , float ]] = ( 0 , 1 ), out_range : Tuple [ Union [ int , float ], Union [ int , float ]] = ( 1 , 255 ) ) -> numpy . ndarray Linear rescaling. Attributes ---------- image : numpy ndarray Image array to rescale. in_range : list, int, optional, (default: [0,1]) Image min/max value to rescale. out_range : list, int, optional, (default: [1,255]) output min/max bounds to rescale to. Returns ------- out : numpy ndarray returns rescaled image array. mapzen_elevation_rgb \u00b6 def mapzen_elevation_rgb ( arr : numpy . ndarray ) -> numpy . ndarray Encode elevation value to RGB values compatible with Mapzen tangram. Attributes ---------- arr : numpy ndarray Image array to encode. Returns ------- out : numpy ndarray RGB array (3, h, w) non_alpha_indexes \u00b6 def non_alpha_indexes ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ] ) -> Tuple Return indexes of non-alpha bands. pansharpening_brovey \u00b6 def pansharpening_brovey ( rgb : numpy . ndarray , pan : numpy . ndarray , weight : float , pan_dtype : str ) -> numpy . ndarray Brovey Method: Each resampled, multispectral pixel is multiplied by the ratio of the corresponding panchromatic pixel intensity to the sum of all the multispectral intensities. Original code from https://github.com/mapbox/rio-pansharpen render \u00b6 def render ( tile : numpy . ndarray , mask : Union [ numpy . ndarray , NoneType ] = None , img_format : str = 'PNG' , colormap : Union [ Dict , NoneType ] = None , ** creation_options : Any ) -> bytes Translate numpy ndarray to image buffer using GDAL. Usage ----- tile, mask = rio_tiler.utils.tile_read(......) with open('test.jpg', 'wb') as f: f.write(render(tile, mask, img_format=\"jpeg\")) Attributes ---------- tile : numpy ndarray Image array to encode. mask: numpy ndarray, optional Mask array img_format: str, optional Image format to return (default: 'png'). List of supported format by GDAL: https://www.gdal.org/formats_list.html colormap: dict, optional GDAL RGBA Color Table dictionary. creation_options: dict, optional Image driver creation options to pass to GDAL Returns ------- bytes: BytesIO Reurn image body. tile_exists \u00b6 def tile_exists ( bounds : Tuple [ float , float , float , float ], tile_z : int , tile_x : int , tile_y : int ) -> bool Check if a mercatile tile is inside a given bounds. Attributes ---------- bounds : list WGS84 bounds (left, bottom, right, top). z : int Mercator tile ZOOM level. y : int Mercator tile Y index. x : int Mercator tile Y index. Returns ------- out : boolean if True, the z-x-y mercator tile in inside the bounds.","title":"Utils"},{"location":"rio_tiler/utils/#module-rio_tilerutils","text":"rio_tiler.utils: utility functions.","title":"Module rio_tiler.utils"},{"location":"rio_tiler/utils/#variables","text":"DataSet","title":"Variables"},{"location":"rio_tiler/utils/#functions","text":"","title":"Functions"},{"location":"rio_tiler/utils/#aws_get_object","text":"def aws_get_object ( bucket : str , key : str , request_pays : bool = False , client : < function Session . client at 0x7fe55aecb680 > = None ) -> bytes AWS s3 get object content.","title":"aws_get_object"},{"location":"rio_tiler/utils/#create_cutline","text":"def create_cutline ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], geometry : Dict , geometry_crs : rasterio . crs . CRS = None ) -> str Create WKT Polygon Cutline for GDALWarpOptions. Ref: https://gdal.org/api/gdalwarp_cpp.html?highlight=vrt#_CPPv415GDALWarpOptions Attributes ---------- src_dst: rasterio.io.DatasetReader rasterio.io.DatasetReader object geometry: dict GeoJSON feature or GeoJSON geometry geometry_crs: CRS or str, optional Specify bounds coordinate reference system, default is same as input dataset. Returns ------- wkt: str Cutline WKT geometry in form of `POLYGON ((x y, x y, ...)))","title":"create_cutline"},{"location":"rio_tiler/utils/#geotiff_options","text":"def geotiff_options ( x : int , y : int , z : int , tilesize : int = 256 , dst_crs : rasterio . crs . CRS = CRS . from_epsg ( 3857 ) ) -> Dict GeoTIFF options. Attributes ---------- x : int Mercator tile X index. y : int Mercator tile Y index. z : int Mercator tile ZOOM level. tilesize : int, optional Output tile size. Default is 256. dst_crs: CRS, optional Target coordinate reference system, default is \"epsg:3857\". Returns ------- dict","title":"geotiff_options"},{"location":"rio_tiler/utils/#get_overview_level","text":"def get_overview_level ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Tuple [ float , float , float , float ], height : int , width : int , dst_crs : rasterio . crs . CRS = CRS . from_epsg ( 3857 ) ) -> int Return the overview level corresponding to the tile resolution. Freely adapted from https://github.com/OSGeo/gdal/blob/41993f127e6e1669fbd9e944744b7c9b2bd6c400/gdal/apps/gdalwarp_lib.cpp#L2293-L2362 Attributes ---------- src_dst : rasterio.io.DatasetReader Rasterio io.DatasetReader object bounds : list Bounds (left, bottom, right, top) in target crs (\"dst_crs\"). height : int Output height. width : int Output width. dst_crs: CRS or str, optional Target coordinate reference system (default \"epsg:3857\"). Returns ------- ovr_idx: Int or None Overview level","title":"get_overview_level"},{"location":"rio_tiler/utils/#get_vrt_transform","text":"def get_vrt_transform ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ], bounds : Tuple [ float , float , float , float ], height : Union [ int , NoneType ] = None , width : Union [ int , NoneType ] = None , dst_crs : rasterio . crs . CRS = CRS . from_epsg ( 3857 ) ) -> Tuple [ affine . Affine , int , int ] Calculate VRT transform. Attributes ---------- src_dst : rasterio.io.DatasetReader Rasterio io.DatasetReader object bounds : list Bounds (left, bottom, right, top) in target crs (\"dst_crs\"). height : int, optional Desired output height of the array for the bounds. width : int, optional Desired output width of the array for the bounds. dst_crs: CRS or str, optional Target coordinate reference system (default \"epsg:3857\"). Returns ------- vrt_transform: Affine Output affine transformation matrix vrt_width, vrt_height: int Output dimensions","title":"get_vrt_transform"},{"location":"rio_tiler/utils/#has_alpha_band","text":"def has_alpha_band ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ] ) -> bool Check for alpha band or mask in source.","title":"has_alpha_band"},{"location":"rio_tiler/utils/#has_mask_band","text":"def has_mask_band ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ] ) -> bool Check for mask band in source.","title":"has_mask_band"},{"location":"rio_tiler/utils/#linear_rescale","text":"def linear_rescale ( image : numpy . ndarray , in_range : Tuple [ Union [ int , float ], Union [ int , float ]] = ( 0 , 1 ), out_range : Tuple [ Union [ int , float ], Union [ int , float ]] = ( 1 , 255 ) ) -> numpy . ndarray Linear rescaling. Attributes ---------- image : numpy ndarray Image array to rescale. in_range : list, int, optional, (default: [0,1]) Image min/max value to rescale. out_range : list, int, optional, (default: [1,255]) output min/max bounds to rescale to. Returns ------- out : numpy ndarray returns rescaled image array.","title":"linear_rescale"},{"location":"rio_tiler/utils/#mapzen_elevation_rgb","text":"def mapzen_elevation_rgb ( arr : numpy . ndarray ) -> numpy . ndarray Encode elevation value to RGB values compatible with Mapzen tangram. Attributes ---------- arr : numpy ndarray Image array to encode. Returns ------- out : numpy ndarray RGB array (3, h, w)","title":"mapzen_elevation_rgb"},{"location":"rio_tiler/utils/#non_alpha_indexes","text":"def non_alpha_indexes ( src_dst : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . vrt . WarpedVRT ] ) -> Tuple Return indexes of non-alpha bands.","title":"non_alpha_indexes"},{"location":"rio_tiler/utils/#pansharpening_brovey","text":"def pansharpening_brovey ( rgb : numpy . ndarray , pan : numpy . ndarray , weight : float , pan_dtype : str ) -> numpy . ndarray Brovey Method: Each resampled, multispectral pixel is multiplied by the ratio of the corresponding panchromatic pixel intensity to the sum of all the multispectral intensities. Original code from https://github.com/mapbox/rio-pansharpen","title":"pansharpening_brovey"},{"location":"rio_tiler/utils/#render","text":"def render ( tile : numpy . ndarray , mask : Union [ numpy . ndarray , NoneType ] = None , img_format : str = 'PNG' , colormap : Union [ Dict , NoneType ] = None , ** creation_options : Any ) -> bytes Translate numpy ndarray to image buffer using GDAL. Usage ----- tile, mask = rio_tiler.utils.tile_read(......) with open('test.jpg', 'wb') as f: f.write(render(tile, mask, img_format=\"jpeg\")) Attributes ---------- tile : numpy ndarray Image array to encode. mask: numpy ndarray, optional Mask array img_format: str, optional Image format to return (default: 'png'). List of supported format by GDAL: https://www.gdal.org/formats_list.html colormap: dict, optional GDAL RGBA Color Table dictionary. creation_options: dict, optional Image driver creation options to pass to GDAL Returns ------- bytes: BytesIO Reurn image body.","title":"render"},{"location":"rio_tiler/utils/#tile_exists","text":"def tile_exists ( bounds : Tuple [ float , float , float , float ], tile_z : int , tile_x : int , tile_y : int ) -> bool Check if a mercatile tile is inside a given bounds. Attributes ---------- bounds : list WGS84 bounds (left, bottom, right, top). z : int Mercator tile ZOOM level. y : int Mercator tile Y index. x : int Mercator tile Y index. Returns ------- out : boolean if True, the z-x-y mercator tile in inside the bounds.","title":"tile_exists"},{"location":"rio_tiler/io/base/","text":"Module rio_tiler.io.base \u00b6 rio_tiler.io.base: ABC class for rio-tiler readers. Classes \u00b6 BaseReader \u00b6 class BaseReader ( ) Rio-tiler.io BaseReader. Descendants \u00b6 rio_tiler.io.base.MultiBaseReader rio_tiler.io.cogeo.COGReader Instance variables \u00b6 center Dataset center + minzoom. spatial_info Return Dataset's spatial info. Methods \u00b6 info \u00b6 def info ( self ) -> Dict Return Dataset's info. metadata \u00b6 def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , ** kwargs : Any ) -> Dict Return Dataset's statistics and info. part \u00b6 def part ( self , bbox : Tuple [ float , float , float , float ], ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Part of a Dataset. point \u00b6 def point ( self , lon : float , lat : float , ** kwargs : Any ) -> List Read a value from a Dataset. preview \u00b6 def preview ( self , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview of a Dataset. stats \u00b6 def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Return Dataset's statistics. tile \u00b6 def tile ( self , tile_x : int , tile_y : int , tile_z : int , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Map tile from the Dataset. MultiBaseReader \u00b6 class MultiBaseReader ( reader : Type [ rio_tiler . io . base . BaseReader ], reader_options : Dict = NOTHING ) MultiBaseReader Reader. Ancestors (in MRO) \u00b6 rio_tiler.io.base.BaseReader Descendants \u00b6 rio_tiler.io.stac.STACReader Instance variables \u00b6 center Dataset center + minzoom. spatial_info Return Dataset's spatial info. Methods \u00b6 info \u00b6 def info ( self , assets : Union [ Sequence [ str ], str ] = None , * args , ** kwargs : Any ) -> Dict Return metadata from multiple assets metadata \u00b6 def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return metadata from multiple assets parse_expression \u00b6 def parse_expression ( self , expression : str ) -> Tuple Parse rio-tiler band math expression. part \u00b6 def part ( self , bbox : Tuple [ float , float , float , float ], assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of multiple assets. point \u00b6 def point ( self , lon : float , lat : float , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> List Read a value from COGs. preview \u00b6 def preview ( self , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview from multiple assets. stats \u00b6 def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return array statistics from multiple assets tile \u00b6 def tile ( self , tile_x : int , tile_y : int , tile_z : int , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Mercator Map tile multiple assets.","title":"Base"},{"location":"rio_tiler/io/base/#module-rio_tileriobase","text":"rio_tiler.io.base: ABC class for rio-tiler readers.","title":"Module rio_tiler.io.base"},{"location":"rio_tiler/io/base/#classes","text":"","title":"Classes"},{"location":"rio_tiler/io/base/#basereader","text":"class BaseReader ( ) Rio-tiler.io BaseReader.","title":"BaseReader"},{"location":"rio_tiler/io/base/#descendants","text":"rio_tiler.io.base.MultiBaseReader rio_tiler.io.cogeo.COGReader","title":"Descendants"},{"location":"rio_tiler/io/base/#instance-variables","text":"center Dataset center + minzoom. spatial_info Return Dataset's spatial info.","title":"Instance variables"},{"location":"rio_tiler/io/base/#methods","text":"","title":"Methods"},{"location":"rio_tiler/io/base/#info","text":"def info ( self ) -> Dict Return Dataset's info.","title":"info"},{"location":"rio_tiler/io/base/#metadata","text":"def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , ** kwargs : Any ) -> Dict Return Dataset's statistics and info.","title":"metadata"},{"location":"rio_tiler/io/base/#part","text":"def part ( self , bbox : Tuple [ float , float , float , float ], ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Part of a Dataset.","title":"part"},{"location":"rio_tiler/io/base/#point","text":"def point ( self , lon : float , lat : float , ** kwargs : Any ) -> List Read a value from a Dataset.","title":"point"},{"location":"rio_tiler/io/base/#preview","text":"def preview ( self , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview of a Dataset.","title":"preview"},{"location":"rio_tiler/io/base/#stats","text":"def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Return Dataset's statistics.","title":"stats"},{"location":"rio_tiler/io/base/#tile","text":"def tile ( self , tile_x : int , tile_y : int , tile_z : int , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Map tile from the Dataset.","title":"tile"},{"location":"rio_tiler/io/base/#multibasereader","text":"class MultiBaseReader ( reader : Type [ rio_tiler . io . base . BaseReader ], reader_options : Dict = NOTHING ) MultiBaseReader Reader.","title":"MultiBaseReader"},{"location":"rio_tiler/io/base/#ancestors-in-mro","text":"rio_tiler.io.base.BaseReader","title":"Ancestors (in MRO)"},{"location":"rio_tiler/io/base/#descendants_1","text":"rio_tiler.io.stac.STACReader","title":"Descendants"},{"location":"rio_tiler/io/base/#instance-variables_1","text":"center Dataset center + minzoom. spatial_info Return Dataset's spatial info.","title":"Instance variables"},{"location":"rio_tiler/io/base/#methods_1","text":"","title":"Methods"},{"location":"rio_tiler/io/base/#info_1","text":"def info ( self , assets : Union [ Sequence [ str ], str ] = None , * args , ** kwargs : Any ) -> Dict Return metadata from multiple assets","title":"info"},{"location":"rio_tiler/io/base/#metadata_1","text":"def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return metadata from multiple assets","title":"metadata"},{"location":"rio_tiler/io/base/#parse_expression","text":"def parse_expression ( self , expression : str ) -> Tuple Parse rio-tiler band math expression.","title":"parse_expression"},{"location":"rio_tiler/io/base/#part_1","text":"def part ( self , bbox : Tuple [ float , float , float , float ], assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of multiple assets.","title":"part"},{"location":"rio_tiler/io/base/#point_1","text":"def point ( self , lon : float , lat : float , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> List Read a value from COGs.","title":"point"},{"location":"rio_tiler/io/base/#preview_1","text":"def preview ( self , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview from multiple assets.","title":"preview"},{"location":"rio_tiler/io/base/#stats_1","text":"def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return array statistics from multiple assets","title":"stats"},{"location":"rio_tiler/io/base/#tile_1","text":"def tile ( self , tile_x : int , tile_y : int , tile_z : int , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Mercator Map tile multiple assets.","title":"tile"},{"location":"rio_tiler/io/cogeo/","text":"Module rio_tiler.io.cogeo \u00b6 rio_tiler.io.cogeo: raster processing. Functions \u00b6 multi_info \u00b6 def multi_info ( assets : Sequence [ str ] ) -> List Assemble multiple COGReader.info. multi_metadata \u00b6 def multi_metadata ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> List Assemble multiple COGReader.metadata. multi_part \u00b6 def multi_part ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Assemble multiple COGReader.part. multi_point \u00b6 def multi_point ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> List Assemble multiple COGReader.point. multi_preview \u00b6 def multi_preview ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Assemble multiple COGReader.preview. multi_stats \u00b6 def multi_stats ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> List Assemble multiple COGReader.stats. multi_tile \u00b6 def multi_tile ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Assemble multiple tiles. Classes \u00b6 COGReader \u00b6 class COGReader ( filepath : str , dataset : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . io . MemoryFile , rasterio . vrt . WarpedVRT ] = None , minzoom : int = None , maxzoom : int = None , colormap : Dict = None , nodata : Union [ float , int , str , NoneType ] = None , unscale : Union [ bool , NoneType ] = None , vrt_options : Union [ Dict , NoneType ] = None ) Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics Ancestors (in MRO) \u00b6 rio_tiler.io.base.BaseReader Instance variables \u00b6 center Dataset center + minzoom. spatial_info Return Dataset's spatial info. Methods \u00b6 info \u00b6 def info ( self ) -> Dict Return COG info. metadata \u00b6 def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , ** kwargs : Any ) -> Dict Return COG info and statistics. part \u00b6 def part ( self , bbox : Tuple [ float , float , float , float ], dst_crs : Union [ rasterio . crs . CRS , NoneType ] = None , bounds_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), max_size : int = 1024 , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of a COG. Attributes ---------- bbox: tuple bounds to read (left, bottom, right, top) in \"bounds_crs\". dst_crs: CRS or str, optional Target coordinate reference system, default is the bbox CRS. bounds_crs: CRS or str, optional bounds coordinate reference system, default is \"epsg:4326\" max_size: int, optional Limit output size array, default is 1024. indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.part' function. Returns ------- data: numpy ndarray mask: numpy array point \u00b6 def point ( self , lon : float , lat : float , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> List Read a value from a COG. Attributes ---------- address: str file url. lon: float Longitude lat: float Latittude. indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.point' function. Returns ------- point: list List of pixel values per bands indexes. preview \u00b6 def preview ( self , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview of a COG. Attributes ---------- indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.preview' function. Returns ------- data: numpy ndarray mask: numpy array stats \u00b6 def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Return bands statistics from a COG. Attributes ---------- pmin: float, optional, (default: 2) Histogram minimum cut. pmax: float, optional, (default: 98) Histogram maximum cut. hist_options: dict, optional Options to forward to numpy.histogram function. e.g: {bins=20, range=(0, 1000)} kwargs: optional These are passed to 'rio_tiler.reader.stats' Returns ------- out: dict Dictionary with bands statistics. tile \u00b6 def tile ( self , tile_x : int , tile_y : int , tile_z : int , tilesize : int = 256 , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Mercator Map tile from a COG. Attributes ---------- tile_x: int Mercator tile X index. tile_y: int Mercator tile Y index. tile_z: int Mercator tile ZOOM level. tilesize: int, optional (default: 256) Output image size. indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.part' function. Returns ------- data: numpy ndarray mask: numpy array","title":"COG"},{"location":"rio_tiler/io/cogeo/#module-rio_tileriocogeo","text":"rio_tiler.io.cogeo: raster processing.","title":"Module rio_tiler.io.cogeo"},{"location":"rio_tiler/io/cogeo/#functions","text":"","title":"Functions"},{"location":"rio_tiler/io/cogeo/#multi_info","text":"def multi_info ( assets : Sequence [ str ] ) -> List Assemble multiple COGReader.info.","title":"multi_info"},{"location":"rio_tiler/io/cogeo/#multi_metadata","text":"def multi_metadata ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> List Assemble multiple COGReader.metadata.","title":"multi_metadata"},{"location":"rio_tiler/io/cogeo/#multi_part","text":"def multi_part ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Assemble multiple COGReader.part.","title":"multi_part"},{"location":"rio_tiler/io/cogeo/#multi_point","text":"def multi_point ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> List Assemble multiple COGReader.point.","title":"multi_point"},{"location":"rio_tiler/io/cogeo/#multi_preview","text":"def multi_preview ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Assemble multiple COGReader.preview.","title":"multi_preview"},{"location":"rio_tiler/io/cogeo/#multi_stats","text":"def multi_stats ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> List Assemble multiple COGReader.stats.","title":"multi_stats"},{"location":"rio_tiler/io/cogeo/#multi_tile","text":"def multi_tile ( assets : Sequence [ str ], * args : Any , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Assemble multiple tiles.","title":"multi_tile"},{"location":"rio_tiler/io/cogeo/#classes","text":"","title":"Classes"},{"location":"rio_tiler/io/cogeo/#cogreader","text":"class COGReader ( filepath : str , dataset : Union [ rasterio . io . DatasetReader , rasterio . io . DatasetWriter , rasterio . io . MemoryFile , rasterio . vrt . WarpedVRT ] = None , minzoom : int = None , maxzoom : int = None , colormap : Dict = None , nodata : Union [ float , int , str , NoneType ] = None , unscale : Union [ bool , NoneType ] = None , vrt_options : Union [ Dict , NoneType ] = None ) Cloud Optimized GeoTIFF Reader. Examples -------- with COGReader(src_path) as cog: cog.tile(...) # Set global options with COGReader(src_path, unscale=True, nodata=0) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with WarpedVRT(src_dst, ...) as vrt_dst: with COGReader(None, dataset=vrt_dst) as cog: cog.tile(...) with rasterio.open(src_path) as src_dst: with COGReader(None, dataset=src_dst) as cog: cog.tile(...) Attributes ---------- filepath: str Cloud Optimized GeoTIFF path. dataset: rasterio.DatasetReader, optional Rasterio dataset. Properties ---------- minzoom: int COG minimum zoom level. maxzoom: int COG maximum zoom level. bounds: tuple[float] COG bounds in WGS84 crs. center: tuple[float, float, int] COG center + minzoom colormap: dict COG internal colormap. info: dict General information about the COG (datatype, indexes, ...) Methods ------- tile(0, 0, 0, indexes=(1,2,3), expression=\"\u001dB1/B2\", tilesize=512, resampling_methods=\"nearest\") Read a map tile from the COG. part((0,10,0,10), indexes=(1,2,3,), expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(max_size=1024) Read preview of the COG. point((10, 10), indexes=1) Read a point value from the COG. stats(pmin=5, pmax=95) Get Raster statistics. meta(pmin=5, pmax=95) Get info + raster statistics","title":"COGReader"},{"location":"rio_tiler/io/cogeo/#ancestors-in-mro","text":"rio_tiler.io.base.BaseReader","title":"Ancestors (in MRO)"},{"location":"rio_tiler/io/cogeo/#instance-variables","text":"center Dataset center + minzoom. spatial_info Return Dataset's spatial info.","title":"Instance variables"},{"location":"rio_tiler/io/cogeo/#methods","text":"","title":"Methods"},{"location":"rio_tiler/io/cogeo/#info","text":"def info ( self ) -> Dict Return COG info.","title":"info"},{"location":"rio_tiler/io/cogeo/#metadata","text":"def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , ** kwargs : Any ) -> Dict Return COG info and statistics.","title":"metadata"},{"location":"rio_tiler/io/cogeo/#part","text":"def part ( self , bbox : Tuple [ float , float , float , float ], dst_crs : Union [ rasterio . crs . CRS , NoneType ] = None , bounds_crs : rasterio . crs . CRS = CRS . from_epsg ( 4326 ), max_size : int = 1024 , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of a COG. Attributes ---------- bbox: tuple bounds to read (left, bottom, right, top) in \"bounds_crs\". dst_crs: CRS or str, optional Target coordinate reference system, default is the bbox CRS. bounds_crs: CRS or str, optional bounds coordinate reference system, default is \"epsg:4326\" max_size: int, optional Limit output size array, default is 1024. indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.part' function. Returns ------- data: numpy ndarray mask: numpy array","title":"part"},{"location":"rio_tiler/io/cogeo/#point","text":"def point ( self , lon : float , lat : float , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> List Read a value from a COG. Attributes ---------- address: str file url. lon: float Longitude lat: float Latittude. indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.point' function. Returns ------- point: list List of pixel values per bands indexes.","title":"point"},{"location":"rio_tiler/io/cogeo/#preview","text":"def preview ( self , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview of a COG. Attributes ---------- indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.preview' function. Returns ------- data: numpy ndarray mask: numpy array","title":"preview"},{"location":"rio_tiler/io/cogeo/#stats","text":"def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , ** kwargs : Any ) -> Dict Return bands statistics from a COG. Attributes ---------- pmin: float, optional, (default: 2) Histogram minimum cut. pmax: float, optional, (default: 98) Histogram maximum cut. hist_options: dict, optional Options to forward to numpy.histogram function. e.g: {bins=20, range=(0, 1000)} kwargs: optional These are passed to 'rio_tiler.reader.stats' Returns ------- out: dict Dictionary with bands statistics.","title":"stats"},{"location":"rio_tiler/io/cogeo/#tile","text":"def tile ( self , tile_x : int , tile_y : int , tile_z : int , tilesize : int = 256 , indexes : Union [ int , Sequence , NoneType ] = None , expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Mercator Map tile from a COG. Attributes ---------- tile_x: int Mercator tile X index. tile_y: int Mercator tile Y index. tile_z: int Mercator tile ZOOM level. tilesize: int, optional (default: 256) Output image size. indexes: int or sequence of int Band indexes (e.g. 1 or (1, 2, 3)) expression: str rio-tiler expression (e.g. b1/b2+b3) kwargs: dict, optional These will be passed to the 'rio_tiler.reader.part' function. Returns ------- data: numpy ndarray mask: numpy array","title":"tile"},{"location":"rio_tiler/io/stac/","text":"Module rio_tiler.io.stac \u00b6 rio_tiler.io.stac: STAC reader. Variables \u00b6 DEFAULT_VALID_TYPE Functions \u00b6 fetch \u00b6 def fetch ( filepath : str ) -> Dict Fetch items. Classes \u00b6 STACReader \u00b6 class STACReader ( filepath : str , item : Dict = None , minzoom : int = 0 , maxzoom : int = 30 , include_assets : Union [ Set [ str ], NoneType ] = None , exclude_assets : Union [ Set [ str ], NoneType ] = None , include_asset_types : Set [ str ] = { 'image/tiff' , 'image/x.geotiff' , 'application/x-hdf' , 'image/jp2' , 'image/tiff; application=geotiff' , 'image/vnd.stac.geotiff; cloud-optimized=true' , 'image/tiff; application=geotiff; profile=cloud-optimized' , 'application/x-hdf5' }, exclude_asset_types : Union [ Set [ str ], NoneType ] = None , reader : Type [ rio_tiler . io . base . BaseReader ] = < class ' rio_tiler . io . cogeo . COGReader '>, reader_options : Dict = NOTHING ) STAC + Cloud Optimized GeoTIFF Reader. Examples -------- with STACReader(stac_path) as stac: stac.tile(...) with STACReader(stac_path, reader=MyCustomReader, reader_options={...}) as stac: stac.tile(...) my_stac = { \"type\": \"Feature\", \"stac_version\": \"1.0.0\", ... } with STACReader(None, item=my_stac) as stac: stac.tile(...) Attributes ---------- filepath: str STAC Item path, URL or S3 URL. item: Dict, optional STAC Item dict. minzoom: int, optional Set minzoom for the tiles. minzoom: int, optional Set maxzoom for the tiles. include_assets: Set, optional Only accept some assets. exclude_assets: Set, optional Exclude some assets. include_asset_types: Set, optional Only include some assets base on their type include_asset_types: Set, optional Exclude some assets base on their type reader: BaseReader, optional rio-tiler Reader (default is set to rio_tiler.io.COGReader) reader_options: dict, optional additional option to forward to the Reader (default is {}). Properties ---------- bounds: tuple[float] STAC bounds in WGS84 crs. center: tuple[float, float, int] STAC item center + minzoom spatial_info: dict STAC spatial info (zoom, bounds and center) Methods ------- tile(0, 0, 0, assets=\"B01\", expression=\"\u001dB01/B02\") Read a map tile from the COG. part((0,10,0,10), assets=\"B01\", expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(assets=\"B01\", max_size=1024) Read preview of the COG. point((10, 10), assets=\"B01\") Read a point value from the COG. stats(assets=\"B01\", pmin=5, pmax=95) Get Raster statistics. info(assets=\"B01\") Get Assets raster info. metadata(assets=\"B01\", pmin=5, pmax=95) info + stats Ancestors (in MRO) \u00b6 rio_tiler.io.base.MultiBaseReader rio_tiler.io.base.BaseReader Instance variables \u00b6 center Dataset center + minzoom. spatial_info Return Dataset's spatial info. Methods \u00b6 info \u00b6 def info ( self , assets : Union [ Sequence [ str ], str ] = None , * args , ** kwargs : Any ) -> Dict Return metadata from multiple assets metadata \u00b6 def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return metadata from multiple assets parse_expression \u00b6 def parse_expression ( self , expression : str ) -> Tuple Parse rio-tiler band math expression. part \u00b6 def part ( self , bbox : Tuple [ float , float , float , float ], assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of multiple assets. point \u00b6 def point ( self , lon : float , lat : float , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> List Read a value from COGs. preview \u00b6 def preview ( self , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview from multiple assets. stats \u00b6 def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return array statistics from multiple assets tile \u00b6 def tile ( self , tile_x : int , tile_y : int , tile_z : int , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Mercator Map tile multiple assets.","title":"STAC"},{"location":"rio_tiler/io/stac/#module-rio_tileriostac","text":"rio_tiler.io.stac: STAC reader.","title":"Module rio_tiler.io.stac"},{"location":"rio_tiler/io/stac/#variables","text":"DEFAULT_VALID_TYPE","title":"Variables"},{"location":"rio_tiler/io/stac/#functions","text":"","title":"Functions"},{"location":"rio_tiler/io/stac/#fetch","text":"def fetch ( filepath : str ) -> Dict Fetch items.","title":"fetch"},{"location":"rio_tiler/io/stac/#classes","text":"","title":"Classes"},{"location":"rio_tiler/io/stac/#stacreader","text":"class STACReader ( filepath : str , item : Dict = None , minzoom : int = 0 , maxzoom : int = 30 , include_assets : Union [ Set [ str ], NoneType ] = None , exclude_assets : Union [ Set [ str ], NoneType ] = None , include_asset_types : Set [ str ] = { 'image/tiff' , 'image/x.geotiff' , 'application/x-hdf' , 'image/jp2' , 'image/tiff; application=geotiff' , 'image/vnd.stac.geotiff; cloud-optimized=true' , 'image/tiff; application=geotiff; profile=cloud-optimized' , 'application/x-hdf5' }, exclude_asset_types : Union [ Set [ str ], NoneType ] = None , reader : Type [ rio_tiler . io . base . BaseReader ] = < class ' rio_tiler . io . cogeo . COGReader '>, reader_options : Dict = NOTHING ) STAC + Cloud Optimized GeoTIFF Reader. Examples -------- with STACReader(stac_path) as stac: stac.tile(...) with STACReader(stac_path, reader=MyCustomReader, reader_options={...}) as stac: stac.tile(...) my_stac = { \"type\": \"Feature\", \"stac_version\": \"1.0.0\", ... } with STACReader(None, item=my_stac) as stac: stac.tile(...) Attributes ---------- filepath: str STAC Item path, URL or S3 URL. item: Dict, optional STAC Item dict. minzoom: int, optional Set minzoom for the tiles. minzoom: int, optional Set maxzoom for the tiles. include_assets: Set, optional Only accept some assets. exclude_assets: Set, optional Exclude some assets. include_asset_types: Set, optional Only include some assets base on their type include_asset_types: Set, optional Exclude some assets base on their type reader: BaseReader, optional rio-tiler Reader (default is set to rio_tiler.io.COGReader) reader_options: dict, optional additional option to forward to the Reader (default is {}). Properties ---------- bounds: tuple[float] STAC bounds in WGS84 crs. center: tuple[float, float, int] STAC item center + minzoom spatial_info: dict STAC spatial info (zoom, bounds and center) Methods ------- tile(0, 0, 0, assets=\"B01\", expression=\"\u001dB01/B02\") Read a map tile from the COG. part((0,10,0,10), assets=\"B01\", expression=\"\u001dB1/B20\", max_size=1024) Read part of the COG. preview(assets=\"B01\", max_size=1024) Read preview of the COG. point((10, 10), assets=\"B01\") Read a point value from the COG. stats(assets=\"B01\", pmin=5, pmax=95) Get Raster statistics. info(assets=\"B01\") Get Assets raster info. metadata(assets=\"B01\", pmin=5, pmax=95) info + stats","title":"STACReader"},{"location":"rio_tiler/io/stac/#ancestors-in-mro","text":"rio_tiler.io.base.MultiBaseReader rio_tiler.io.base.BaseReader","title":"Ancestors (in MRO)"},{"location":"rio_tiler/io/stac/#instance-variables","text":"center Dataset center + minzoom. spatial_info Return Dataset's spatial info.","title":"Instance variables"},{"location":"rio_tiler/io/stac/#methods","text":"","title":"Methods"},{"location":"rio_tiler/io/stac/#info","text":"def info ( self , assets : Union [ Sequence [ str ], str ] = None , * args , ** kwargs : Any ) -> Dict Return metadata from multiple assets","title":"info"},{"location":"rio_tiler/io/stac/#metadata","text":"def metadata ( self , pmin : float = 2.0 , pmax : float = 98.0 , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return metadata from multiple assets","title":"metadata"},{"location":"rio_tiler/io/stac/#parse_expression","text":"def parse_expression ( self , expression : str ) -> Tuple Parse rio-tiler band math expression.","title":"parse_expression"},{"location":"rio_tiler/io/stac/#part","text":"def part ( self , bbox : Tuple [ float , float , float , float ], assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read part of multiple assets.","title":"part"},{"location":"rio_tiler/io/stac/#point","text":"def point ( self , lon : float , lat : float , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> List Read a value from COGs.","title":"point"},{"location":"rio_tiler/io/stac/#preview","text":"def preview ( self , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Return a preview from multiple assets.","title":"preview"},{"location":"rio_tiler/io/stac/#stats","text":"def stats ( self , pmin : float = 2.0 , pmax : float = 98.0 , hist_options : Union [ Dict , NoneType ] = None , assets : Union [ Sequence [ str ], str ] = None , ** kwargs : Any ) -> Dict Return array statistics from multiple assets","title":"stats"},{"location":"rio_tiler/io/stac/#tile","text":"def tile ( self , tile_x : int , tile_y : int , tile_z : int , assets : Union [ Sequence [ str ], str ] = None , expression : Union [ str , NoneType ] = '' , asset_expression : Union [ str , NoneType ] = '' , ** kwargs : Any ) -> Tuple [ numpy . ndarray , numpy . ndarray ] Read a Mercator Map tile multiple assets.","title":"tile"},{"location":"rio_tiler/mosaic/reader/","text":"Module rio_tiler.mosaic.reader \u00b6 rio_tiler.mosaic: create tile from multiple assets. Variables \u00b6 MAX_THREADS Functions \u00b6 mosaic_reader \u00b6 def mosaic_reader ( assets : Sequence [ str ], reader : Callable , * args : Any , pixel_selection : Union [ rio_tiler . mosaic . methods . base . MosaicMethodBase , NoneType ] = None , chunk_size : Union [ int , NoneType ] = None , threads : int = 80 , ** kwargs ) -> Tuple [ Tuple [ numpy . ndarray , numpy . ndarray ], Sequence [ str ]] Merge multiple assets. Attributes ---------- assets: list or tuple List of tiler compatible asset. reader: callable reader function. The function MUST take asset, *args, **kwargs as arguments, and MUST return a tuple with tile data and mask e.g: def reader(asset: str, *args, **kwargs) -> Tuple[numpy.ndarray, numpy.ndarray]: with COGReader(asset) as cog: return cog.tile(*args, **kwargs) def reader(asset: str, *args, **kwargs) -> Tuple[numpy.ndarray, numpy.ndarray]: with COGReader(asset) as cog: return cog.preview(*args, **kwargs) args: Any additional argument to forward to the reader function. pixel_selection: MosaicMethod, optional Instance of MosaicMethodBase class. default: \"rio_tiler.mosaic.methods.defaults.FirstMethod\". chunk_size: int, optional Control the number of asset to process per loop (default = threads). threads: int, optional Number of threads to use. If <= 1, runs single threaded without an event loop. By default reads from the MAX_THREADS environment variable, and if not found defaults to multiprocessing.cpu_count() * 5. kwargs: dict, optional tiler specific options. Returns ------- (tile, mask), assets_used : tuple of ndarray, sequence of str Return (tile, mask) data and list of assets used. mosaic_tiler \u00b6 def mosaic_tiler ( assets : Sequence [ str ], tile_x : int , tile_y : int , tile_z : int , reader : Callable , pixel_selection : Union [ rio_tiler . mosaic . methods . base . MosaicMethodBase , NoneType ] = None , chunk_size : Union [ int , NoneType ] = None , threads : int = 80 , ** kwargs ) -> Tuple [ Tuple [ numpy . ndarray , numpy . ndarray ], Sequence [ str ]] Wrapper around mosaic_reader from compatibility with previous rio_tiler_mosaic.","title":"Reader"},{"location":"rio_tiler/mosaic/reader/#module-rio_tilermosaicreader","text":"rio_tiler.mosaic: create tile from multiple assets.","title":"Module rio_tiler.mosaic.reader"},{"location":"rio_tiler/mosaic/reader/#variables","text":"MAX_THREADS","title":"Variables"},{"location":"rio_tiler/mosaic/reader/#functions","text":"","title":"Functions"},{"location":"rio_tiler/mosaic/reader/#mosaic_reader","text":"def mosaic_reader ( assets : Sequence [ str ], reader : Callable , * args : Any , pixel_selection : Union [ rio_tiler . mosaic . methods . base . MosaicMethodBase , NoneType ] = None , chunk_size : Union [ int , NoneType ] = None , threads : int = 80 , ** kwargs ) -> Tuple [ Tuple [ numpy . ndarray , numpy . ndarray ], Sequence [ str ]] Merge multiple assets. Attributes ---------- assets: list or tuple List of tiler compatible asset. reader: callable reader function. The function MUST take asset, *args, **kwargs as arguments, and MUST return a tuple with tile data and mask e.g: def reader(asset: str, *args, **kwargs) -> Tuple[numpy.ndarray, numpy.ndarray]: with COGReader(asset) as cog: return cog.tile(*args, **kwargs) def reader(asset: str, *args, **kwargs) -> Tuple[numpy.ndarray, numpy.ndarray]: with COGReader(asset) as cog: return cog.preview(*args, **kwargs) args: Any additional argument to forward to the reader function. pixel_selection: MosaicMethod, optional Instance of MosaicMethodBase class. default: \"rio_tiler.mosaic.methods.defaults.FirstMethod\". chunk_size: int, optional Control the number of asset to process per loop (default = threads). threads: int, optional Number of threads to use. If <= 1, runs single threaded without an event loop. By default reads from the MAX_THREADS environment variable, and if not found defaults to multiprocessing.cpu_count() * 5. kwargs: dict, optional tiler specific options. Returns ------- (tile, mask), assets_used : tuple of ndarray, sequence of str Return (tile, mask) data and list of assets used.","title":"mosaic_reader"},{"location":"rio_tiler/mosaic/reader/#mosaic_tiler","text":"def mosaic_tiler ( assets : Sequence [ str ], tile_x : int , tile_y : int , tile_z : int , reader : Callable , pixel_selection : Union [ rio_tiler . mosaic . methods . base . MosaicMethodBase , NoneType ] = None , chunk_size : Union [ int , NoneType ] = None , threads : int = 80 , ** kwargs ) -> Tuple [ Tuple [ numpy . ndarray , numpy . ndarray ], Sequence [ str ]] Wrapper around mosaic_reader from compatibility with previous rio_tiler_mosaic.","title":"mosaic_tiler"},{"location":"rio_tiler/mosaic/methods/base/","text":"Module rio_tiler.mosaic.methods.base \u00b6 rio-tiler.mosaic.methods abc class. Classes \u00b6 MosaicMethodBase \u00b6 class MosaicMethodBase ( ) Abstract base class for rio-tiler-mosaic methods objects. Ancestors (in MRO) \u00b6 abc.ABC Descendants \u00b6 rio_tiler.mosaic.methods.defaults.FirstMethod rio_tiler.mosaic.methods.defaults.HighestMethod rio_tiler.mosaic.methods.defaults.LowestMethod rio_tiler.mosaic.methods.defaults.MeanMethod rio_tiler.mosaic.methods.defaults.MedianMethod rio_tiler.mosaic.methods.defaults.StdevMethod Instance variables \u00b6 data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool Methods \u00b6 feed \u00b6 def feed ( self , tile ) Fill mosaic tile. Parameters ---------- tile: numpy.ma.ndarray","title":"Base"},{"location":"rio_tiler/mosaic/methods/base/#module-rio_tilermosaicmethodsbase","text":"rio-tiler.mosaic.methods abc class.","title":"Module rio_tiler.mosaic.methods.base"},{"location":"rio_tiler/mosaic/methods/base/#classes","text":"","title":"Classes"},{"location":"rio_tiler/mosaic/methods/base/#mosaicmethodbase","text":"class MosaicMethodBase ( ) Abstract base class for rio-tiler-mosaic methods objects.","title":"MosaicMethodBase"},{"location":"rio_tiler/mosaic/methods/base/#ancestors-in-mro","text":"abc.ABC","title":"Ancestors (in MRO)"},{"location":"rio_tiler/mosaic/methods/base/#descendants","text":"rio_tiler.mosaic.methods.defaults.FirstMethod rio_tiler.mosaic.methods.defaults.HighestMethod rio_tiler.mosaic.methods.defaults.LowestMethod rio_tiler.mosaic.methods.defaults.MeanMethod rio_tiler.mosaic.methods.defaults.MedianMethod rio_tiler.mosaic.methods.defaults.StdevMethod","title":"Descendants"},{"location":"rio_tiler/mosaic/methods/base/#instance-variables","text":"data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool","title":"Instance variables"},{"location":"rio_tiler/mosaic/methods/base/#methods","text":"","title":"Methods"},{"location":"rio_tiler/mosaic/methods/base/#feed","text":"def feed ( self , tile ) Fill mosaic tile. Parameters ---------- tile: numpy.ma.ndarray","title":"feed"},{"location":"rio_tiler/mosaic/methods/defaults/","text":"Module rio_tiler.mosaic.methods.defaults \u00b6 rio_tiler.mosaic.methods.defaults: default mosaic filling methods. Classes \u00b6 FirstMethod \u00b6 class FirstMethod ( ) Feed the mosaic tile with the first pixel available. Ancestors (in MRO) \u00b6 rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC Instance variables \u00b6 data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool Methods \u00b6 feed \u00b6 def feed ( self , tile ) Add data to tile. HighestMethod \u00b6 class HighestMethod ( ) Feed the mosaic tile with the highest pixel values. Ancestors (in MRO) \u00b6 rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC Instance variables \u00b6 data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool Methods \u00b6 feed \u00b6 def feed ( self , tile ) Add data to tile. LowestMethod \u00b6 class LowestMethod ( ) Feed the mosaic tile with the lowest pixel values. Ancestors (in MRO) \u00b6 rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC Instance variables \u00b6 data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool Methods \u00b6 feed \u00b6 def feed ( self , tile ) Add data to tile. MeanMethod \u00b6 class MeanMethod ( enforce_data_type = True ) Stack the tiles and return the Mean pixel value. Ancestors (in MRO) \u00b6 rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC Instance variables \u00b6 data Return data and mask. is_done Check if the tile filling is done. Returns ------- bool Methods \u00b6 feed \u00b6 def feed ( self , tile ) Add data to tile. MedianMethod \u00b6 class MedianMethod ( enforce_data_type = True ) Stack the tiles and return the Median pixel value. Ancestors (in MRO) \u00b6 rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC Instance variables \u00b6 data Return data and mask. is_done Check if the tile filling is done. Returns ------- bool Methods \u00b6 feed \u00b6 def feed ( self , tile ) Create a stack of tile. StdevMethod \u00b6 class StdevMethod ( enforce_data_type = True ) Stack the tiles and return the Standart Deviation value. Ancestors (in MRO) \u00b6 rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC Instance variables \u00b6 data Return data and mask. is_done Check if the tile filling is done. Returns ------- bool Methods \u00b6 feed \u00b6 def feed ( self , tile ) Add data to tile.","title":"Defaults"},{"location":"rio_tiler/mosaic/methods/defaults/#module-rio_tilermosaicmethodsdefaults","text":"rio_tiler.mosaic.methods.defaults: default mosaic filling methods.","title":"Module rio_tiler.mosaic.methods.defaults"},{"location":"rio_tiler/mosaic/methods/defaults/#classes","text":"","title":"Classes"},{"location":"rio_tiler/mosaic/methods/defaults/#firstmethod","text":"class FirstMethod ( ) Feed the mosaic tile with the first pixel available.","title":"FirstMethod"},{"location":"rio_tiler/mosaic/methods/defaults/#ancestors-in-mro","text":"rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"rio_tiler/mosaic/methods/defaults/#instance-variables","text":"data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool","title":"Instance variables"},{"location":"rio_tiler/mosaic/methods/defaults/#methods","text":"","title":"Methods"},{"location":"rio_tiler/mosaic/methods/defaults/#feed","text":"def feed ( self , tile ) Add data to tile.","title":"feed"},{"location":"rio_tiler/mosaic/methods/defaults/#highestmethod","text":"class HighestMethod ( ) Feed the mosaic tile with the highest pixel values.","title":"HighestMethod"},{"location":"rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_1","text":"rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"rio_tiler/mosaic/methods/defaults/#instance-variables_1","text":"data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool","title":"Instance variables"},{"location":"rio_tiler/mosaic/methods/defaults/#methods_1","text":"","title":"Methods"},{"location":"rio_tiler/mosaic/methods/defaults/#feed_1","text":"def feed ( self , tile ) Add data to tile.","title":"feed"},{"location":"rio_tiler/mosaic/methods/defaults/#lowestmethod","text":"class LowestMethod ( ) Feed the mosaic tile with the lowest pixel values.","title":"LowestMethod"},{"location":"rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_2","text":"rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"rio_tiler/mosaic/methods/defaults/#instance-variables_2","text":"data Return data and mask. Returns ------- tile: numpy.ndarray mask: numpy.ndarray is_done Check if the tile filling is done. Returns ------- bool","title":"Instance variables"},{"location":"rio_tiler/mosaic/methods/defaults/#methods_2","text":"","title":"Methods"},{"location":"rio_tiler/mosaic/methods/defaults/#feed_2","text":"def feed ( self , tile ) Add data to tile.","title":"feed"},{"location":"rio_tiler/mosaic/methods/defaults/#meanmethod","text":"class MeanMethod ( enforce_data_type = True ) Stack the tiles and return the Mean pixel value.","title":"MeanMethod"},{"location":"rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_3","text":"rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"rio_tiler/mosaic/methods/defaults/#instance-variables_3","text":"data Return data and mask. is_done Check if the tile filling is done. Returns ------- bool","title":"Instance variables"},{"location":"rio_tiler/mosaic/methods/defaults/#methods_3","text":"","title":"Methods"},{"location":"rio_tiler/mosaic/methods/defaults/#feed_3","text":"def feed ( self , tile ) Add data to tile.","title":"feed"},{"location":"rio_tiler/mosaic/methods/defaults/#medianmethod","text":"class MedianMethod ( enforce_data_type = True ) Stack the tiles and return the Median pixel value.","title":"MedianMethod"},{"location":"rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_4","text":"rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"rio_tiler/mosaic/methods/defaults/#instance-variables_4","text":"data Return data and mask. is_done Check if the tile filling is done. Returns ------- bool","title":"Instance variables"},{"location":"rio_tiler/mosaic/methods/defaults/#methods_4","text":"","title":"Methods"},{"location":"rio_tiler/mosaic/methods/defaults/#feed_4","text":"def feed ( self , tile ) Create a stack of tile.","title":"feed"},{"location":"rio_tiler/mosaic/methods/defaults/#stdevmethod","text":"class StdevMethod ( enforce_data_type = True ) Stack the tiles and return the Standart Deviation value.","title":"StdevMethod"},{"location":"rio_tiler/mosaic/methods/defaults/#ancestors-in-mro_5","text":"rio_tiler.mosaic.methods.base.MosaicMethodBase abc.ABC","title":"Ancestors (in MRO)"},{"location":"rio_tiler/mosaic/methods/defaults/#instance-variables_5","text":"data Return data and mask. is_done Check if the tile filling is done. Returns ------- bool","title":"Instance variables"},{"location":"rio_tiler/mosaic/methods/defaults/#methods_5","text":"","title":"Methods"},{"location":"rio_tiler/mosaic/methods/defaults/#feed_5","text":"def feed ( self , tile ) Add data to tile.","title":"feed"}]}